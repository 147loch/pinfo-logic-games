var qqwing = function(){

 
  var cellToColumn = function(cell){
    return cell%qqwing.ROW_COL_SEC_SIZE;
  };
  
  var cellToRow = function(cell){
    return Math.floor(cell/qqwing.ROW_COL_SEC_SIZE);
  };
 
  var cellToSectionStartCell = function(cell){
    return Math.floor(cell/qqwing.SEC_GROUP_SIZE)*qqwing.SEC_GROUP_SIZE
        + Math.floor(cellToColumn(cell)/qqwing.GRID_SIZE)*qqwing.GRID_SIZE;
  };
  
 
  var cellToSection = function(cell){
    return Math.floor(cell/qqwing.SEC_GROUP_SIZE)*qqwing.GRID_SIZE
        + Math.floor(cellToColumn(cell)/qqwing.GRID_SIZE);
  };
  
 
  var rowToFirstCell = function(row){
    return qqwing.ROW_COL_SEC_SIZE*row;
  };
  
 
  var columnToFirstCell = function(column){
    return column;
  };
  
 
  var sectionToFirstCell = function(section){
    return (section%qqwing.GRID_SIZE*qqwing.GRID_SIZE) + Math.floor(section/qqwing.GRID_SIZE)*qqwing.SEC_GROUP_SIZE;
  };
  
 
  var getPossibilityIndex = function(valueIndex, cell){
    return valueIndex+(qqwing.ROW_COL_SEC_SIZE*cell);
  };
  
 
  var rowColumnToCell = function(row, column){
    return (row*qqwing.ROW_COL_SEC_SIZE)+column;
  };
  
 
  var sectionToCell = function(section, offset){
    return sectionToFirstCell(section)
        + Math.floor(offset/qqwing.GRID_SIZE)*qqwing.ROW_COL_SEC_SIZE
        + (offset%qqwing.GRID_SIZE);
  };
  
  var println = function(s){
    if ((typeof console != 'undefined') && console.log) console.log(s);
  };
  
  var printnoln = function(s){
    if ((typeof process != 'undefined') && process.stdout && process.stdout.write) process.stdout.write(s);
    else println(s);
  };
  
 
  var puzzle = new Array(qqwing.BOARD_SIZE);
  
 
  var solution = new Array(qqwing.BOARD_SIZE);
  
 
  var solutionRound = new Array(qqwing.BOARD_SIZE);
  
 
  var possibilities = new Array(qqwing.POSSIBILITY_SIZE);
  
 
  var randomBoardArray = new Array(qqwing.BOARD_SIZE);
  
  for (var i=0; i<qqwing.BOARD_SIZE; i++){
    randomBoardArray[i] = i;
  }
  
 
  var randomPossibilityArray = new Array(qqwing.ROW_COL_SEC_SIZE);
  
  for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
    randomPossibilityArray[i] = i;
  }
  
 
  var recordHistory = false;
  
 
  var logHistory = false;
  
 
  var solveHistory = [];
  
 
  var solveInstructions = [];
  
 
  var printStyle = qqwing.PrintStyle.READABLE;
  
 
  var lastSolveRound = 0;
  
 
  var reset = function(){
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      solution[i] = 0;
    }
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      solutionRound[i] = 0;
    }
    for (var i=0; i<qqwing.POSSIBILITY_SIZE; i++){
      possibilities[i] = 0;
    }
    solveHistory = [];
    solveInstructions = [];
  
    var round = 1;
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      if (puzzle[position] > 0){
        var valIndex = puzzle[position]-1;
        var valPos = getPossibilityIndex(valIndex,position);
        var value = puzzle[position];
        if (possibilities[valPos] != 0) return false;
        mark.call(this,position,round,value);
        if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.GIVEN, value, position));
      }
    }
    return true;
  };
  
  var singleSolveMove = function(round){
    if (onlyPossibilityForCell.call(this, round)) return true;
    if (onlyValueInSection.call(this, round)) return true;
    if (onlyValueInRow.call(this, round)) return true;
    if (onlyValueInColumn.call(this, round)) return true;
    if (handleNakedPairs.call(this, round)) return true;
    if (pointingRowReduction.call(this, round)) return true;
    if (pointingColumnReduction.call(this, round)) return true;
    if (rowBoxReduction.call(this, round)) return true;
    if (colBoxReduction.call(this, round)) return true;
    if (hiddenPairInRow.call(this, round)) return true;
    if (hiddenPairInColumn.call(this, round)) return true;
    if (hiddenPairInSection.call(this, round)) return true;
    return false;
  };
  
 
  var onlyPossibilityForCell = function(round){
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      if (solution[position] == 0){
        var count = 0;
        var lastValue = 0;
        for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            count++;
            lastValue=valIndex+1;
          }
        }
        if (count == 1){
          mark.call(this, position, round, lastValue);
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.SINGLE, lastValue, position));
          return true;
        }
      }
    }
    return false;
  };
  
 
  var onlyValueInRow = function(round){
    for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var count = 0;
        var lastPosition = 0;
        for (var col=0; col<qqwing.ROW_COL_SEC_SIZE; col++){
          var position = (row*qqwing.ROW_COL_SEC_SIZE)+col;
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            count++;
            lastPosition = position;
          }
        }
        if (count == 1){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_SINGLE_ROW, value, lastPosition));
          mark.call(this, lastPosition, round, value);
          return true;
        }
      }
    }
    return false;
  }
  
 
  var onlyValueInColumn = function(round){
    for (var col=0; col<qqwing.ROW_COL_SEC_SIZE; col++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var count = 0;
        var lastPosition = 0;
        for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
          var position = rowColumnToCell(row,col);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            count++;
            lastPosition = position;
          }
        }
        if (count == 1){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_SINGLE_COLUMN, value, lastPosition));
          mark.call(this, lastPosition, round, value);
          return true;
        }
      }
    }
    return false;
  }
  
  
 
  var onlyValueInSection = function(round){
    for (var sec=0; sec<qqwing.ROW_COL_SEC_SIZE; sec++){
      var secPos = sectionToFirstCell(sec);
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var count = 0;
        var lastPosition = 0;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var position = secPos + i + qqwing.ROW_COL_SEC_SIZE*j;
            var valPos = getPossibilityIndex(valIndex,position);
            if (possibilities[valPos] == 0){
              count++;
              lastPosition = position;
            }
          }
        }
        if (count == 1){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_SINGLE_SECTION, value, lastPosition));
          mark.call(this, lastPosition, round, value);
          return true;
        }
      }
    }
    return false;
  }
  
  var guess = function(round, guessNumber){
    var localGuessCount = 0;
    var position = findPositionWithFewestPossibilities.call(this);
    for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
      var valIndex = randomPossibilityArray[i];
      var valPos = getPossibilityIndex(valIndex,position);
      if (possibilities[valPos] == 0){
        if (localGuessCount == guessNumber){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.GUESS, value, position));
          mark.call(this, position, round, value);
          return true;
        }
        localGuessCount++;
      }
    }
    return false;
  };
  
  var isImpossible = function(){
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      if (solution[position] == 0){
        var count = 0;
        for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0) count++;
        }
        if (count == 0) {
          return true;
        }
      }
    }
    return false;
  };
  
  var rollbackRound = function(round){
    if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.ROLLBACK));
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (solutionRound[i] == round){
        solutionRound[i] = 0;
        solution[i] = 0;
      }
    }
    {for (var i=0; i<qqwing.POSSIBILITY_SIZE; i++){
      if (possibilities[i] == round){
        possibilities[i] = 0;
      }
    }}
  
    while(solveInstructions.length > 0 && solveInstructions[solveInstructions.length-1] == round){
      solveInstructions.pop();
    }
  };
  
  var pointingRowReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var section=0; section<qqwing.ROW_COL_SEC_SIZE; section++){
        var secStart = sectionToFirstCell(section);
        var inOneRow = true;
        var boxRow = -1;
        for (var j=0; j<qqwing.GRID_SIZE; j++){
          for (var i=0; i<qqwing.GRID_SIZE; i++){
            var secVal=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
            var valPos = getPossibilityIndex(valIndex,secVal);
            if(possibilities[valPos] == 0){
              if (boxRow == -1 || boxRow == j){
                boxRow = j;
              } else {
                inOneRow = false;
              }
            }
          }
        }
        if (inOneRow && boxRow != -1){
          var doneSomething = false;
          var row = cellToRow(secStart) + boxRow;
          var rowStart = rowToFirstCell(row);
  
          for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
            var position = rowStart+i;
            var section2 = cellToSection(position);
            var valPos = getPossibilityIndex(valIndex,position);
            if (section != section2 && possibilities[valPos] == 0){
              possibilities[valPos] = round;
              doneSomething = true;
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.POINTING_PAIR_TRIPLE_ROW, valIndex+1, rowStart));
            return true;
          }
        }
      }
    }
    return false;
  };
  
  var rowBoxReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
        var rowStart = rowToFirstCell(row);
        var inOneBox = true;
        var rowBox = -1;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var column = i*qqwing.GRID_SIZE+j;
            var position = rowColumnToCell(row, column);
            var valPos = getPossibilityIndex(valIndex,position);
            if(possibilities[valPos] == 0){
              if (rowBox == -1 || rowBox == i){
                rowBox = i;
              } else {
                inOneBox = false;
              }
            }
          }
        }
        if (inOneBox && rowBox != -1){
          var doneSomething = false;
          var column = qqwing.GRID_SIZE*rowBox;
          var secStart = cellToSectionStartCell(rowColumnToCell(row, column));
          var secStartRow = cellToRow(secStart);
          var secStartCol = cellToColumn(secStart);
          for (var i=0; i<qqwing.GRID_SIZE; i++){
            for (var j=0; j<qqwing.GRID_SIZE; j++){
              var row2 = secStartRow+i;
              var col2 = secStartCol+j;
              var position = rowColumnToCell(row2, col2);
              var valPos = getPossibilityIndex(valIndex,position);
              if (row != row2 && possibilities[valPos] == 0){
                possibilities[valPos] = round;
                doneSomething = true;
              }
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.ROW_BOX, valIndex+1, rowStart));
            return true;
          }
        }
      }
    }
    return false;
  };
  
  var colBoxReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
        var rowStart = rowToFirstCell(row);
        var inOneBox = true;
        var rowBox = -1;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var column = i*qqwing.GRID_SIZE+j;
            var position = rowColumnToCell(row, column);
            var valPos = getPossibilityIndex(valIndex,position);
            if(possibilities[valPos] == 0){
              if (rowBox == -1 || rowBox == i){
                rowBox = i;
              } else {
                inOneBox = false;
              }
            }
          }
        }
        if (inOneBox && rowBox != -1){
          var doneSomething = false;
          var column = qqwing.GRID_SIZE*rowBox;
          var secStart = cellToSectionStartCell(rowColumnToCell(row, column));
          var secStartRow = cellToRow(secStart);
          var secStartCol = cellToColumn(secStart);
          for (var i=0; i<qqwing.GRID_SIZE; i++){
            for (var j=0; j<qqwing.GRID_SIZE; j++){
              var row2 = secStartRow+i;
              var col2 = secStartCol+j;
              var position = rowColumnToCell(row2, col2);
              var valPos = getPossibilityIndex(valIndex,position);
              if (row != row2 && possibilities[valPos] == 0){
                possibilities[valPos] = round;
                doneSomething = true;
              }
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.ROW_BOX, valIndex+1, rowStart));
            return true;
          }
        }
      }
    }
    return false;
  };
  
  var pointingColumnReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var section=0; section<qqwing.ROW_COL_SEC_SIZE; section++){
        var secStart = sectionToFirstCell(section);
        var inOneCol = true;
        var boxCol = -1;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var secVal=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
            var valPos = getPossibilityIndex(valIndex,secVal);
            if(possibilities[valPos] == 0){
              if (boxCol == -1 || boxCol == i){
                boxCol = i;
              } else {
                inOneCol = false;
              }
            }
          }
        }
        if (inOneCol && boxCol != -1){
          var doneSomething = false;
          var col = cellToColumn(secStart) + boxCol;
          var colStart = columnToFirstCell(col);
  
          for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
            var position = colStart+(qqwing.ROW_COL_SEC_SIZE*i);
            var section2 = cellToSection(position);
            var valPos = getPossibilityIndex(valIndex,position);
            if (section != section2 && possibilities[valPos] == 0){
              possibilities[valPos] = round;
              doneSomething = true;
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.POINTING_PAIR_TRIPLE_COLUMN, valIndex+1, colStart));
            return true;
          }
        }
      }
    }
    return false;
  }
  
  var hiddenPairInRow = function(round){
    for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var c1 = -1;
        var c2 = -1;
        var valCount = 0;
        for (var column=0; column<qqwing.ROW_COL_SEC_SIZE; column++){
          var position = rowColumnToCell(row,column);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            if (c1 == -1 || c1 == column){
              c1 = column;
            } else if (c2 == -1 || c2 == column){
              c2 = column;
            }
            valCount++;
          }
        }
        if (valCount==2){
          for (var valIndex2=valIndex+1; valIndex2<qqwing.ROW_COL_SEC_SIZE; valIndex2++){
            var c3 = -1;
            var c4 = -1;
            var valCount2 = 0;
            for (var column=0; column<qqwing.ROW_COL_SEC_SIZE; column++){
              var position = rowColumnToCell(row,column);
              var valPos = getPossibilityIndex(valIndex2,position);
              if (possibilities[valPos] == 0){
                if (c3 == -1 || c3 == column){
                  c3 = column;
                } else if (c4 == -1 || c4 == column){
                  c4 = column;
                }
                valCount2++;
              }
            }
            if (valCount2==2 && c1==c3 && c2==c4){
              var doneSomething = false;
              for (var valIndex3=0; valIndex3<qqwing.ROW_COL_SEC_SIZE; valIndex3++){
                if (valIndex3 != valIndex && valIndex3 != valIndex2){
                  var position1 = rowColumnToCell(row,c1);
                  var position2 = rowColumnToCell(row,c2);
                  var valPos1 = getPossibilityIndex(valIndex3,position1);
                  var valPos2 = getPossibilityIndex(valIndex3,position2);
                  if (possibilities[valPos1] == 0){
                    possibilities[valPos1] = round;
                    doneSomething = true;
                  }
                  if (possibilities[valPos2] == 0){
                    possibilities[valPos2] = round;
                    doneSomething = true;
                  }
                }
              }
              if (doneSomething){
                if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_PAIR_ROW, valIndex+1, rowColumnToCell(row,c1)));
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var hiddenPairInColumn = function(round){
    for (var column=0; column<qqwing.ROW_COL_SEC_SIZE; column++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var r1 = -1;
        var r2 = -1;
        var valCount = 0;
        for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
          var position = rowColumnToCell(row,column);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            if (r1 == -1 || r1 == row){
              r1 = row;
            } else if (r2 == -1 || r2 == row){
              r2 = row;
            }
            valCount++;
          }
        }
        if (valCount==2){
          for (var valIndex2=valIndex+1; valIndex2<qqwing.ROW_COL_SEC_SIZE; valIndex2++){
            var r3 = -1;
            var r4 = -1;
            var valCount2 = 0;
            for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
              var position = rowColumnToCell(row,column);
              var valPos = getPossibilityIndex(valIndex2,position);
              if (possibilities[valPos] == 0){
                if (r3 == -1 || r3 == row){
                  r3 = row;
                } else if (r4 == -1 || r4 == row){
                  r4 = row;
                }
                valCount2++;
              }
            }
            if (valCount2==2 && r1==r3 && r2==r4){
              var doneSomething = false;
              for (var valIndex3=0; valIndex3<qqwing.ROW_COL_SEC_SIZE; valIndex3++){
                if (valIndex3 != valIndex && valIndex3 != valIndex2){
                  var position1 = rowColumnToCell(r1,column);
                  var position2 = rowColumnToCell(r2,column);
                  var valPos1 = getPossibilityIndex(valIndex3,position1);
                  var valPos2 = getPossibilityIndex(valIndex3,position2);
                  if (possibilities[valPos1] == 0){
                    possibilities[valPos1] = round;
                    doneSomething = true;
                  }
                  if (possibilities[valPos2] == 0){
                    possibilities[valPos2] = round;
                    doneSomething = true;
                  }
                }
              }
              if (doneSomething){
                if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_PAIR_COLUMN, valIndex+1, rowColumnToCell(r1,column)));
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var hiddenPairInSection = function(round){
    for (var section=0; section<qqwing.ROW_COL_SEC_SIZE; section++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var si1 = -1;
        var si2 = -1;
        var valCount = 0;
        for (var secInd=0; secInd<qqwing.ROW_COL_SEC_SIZE; secInd++){
          var position = sectionToCell(section,secInd);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            if (si1 == -1 || si1 == secInd){
              si1 = secInd;
            } else if (si2 == -1 || si2 == secInd){
              si2 = secInd;
            }
            valCount++;
          }
        }
        if (valCount==2){
          for (var valIndex2=valIndex+1; valIndex2<qqwing.ROW_COL_SEC_SIZE; valIndex2++){
            var si3 = -1;
            var si4 = -1;
            var valCount2 = 0;
            for (var secInd=0; secInd<qqwing.ROW_COL_SEC_SIZE; secInd++){
              var position = sectionToCell(section,secInd);
              var valPos = getPossibilityIndex(valIndex2,position);
              if (possibilities[valPos] == 0){
                if (si3 == -1 || si3 == secInd){
                  si3 = secInd;
                } else if (si4 == -1 || si4 == secInd){
                  si4 = secInd;
                }
                valCount2++;
              }
            }
            if (valCount2==2 && si1==si3 && si2==si4){
              var doneSomething = false;
              for (var valIndex3=0; valIndex3<qqwing.ROW_COL_SEC_SIZE; valIndex3++){
                if (valIndex3 != valIndex && valIndex3 != valIndex2){
                  var position1 = sectionToCell(section,si1);
                  var position2 = sectionToCell(section,si2);
                  var valPos1 = getPossibilityIndex(valIndex3,position1);
                  var valPos2 = getPossibilityIndex(valIndex3,position2);
                  if (possibilities[valPos1] == 0){
                    possibilities[valPos1] = round;
                    doneSomething = true;
                  }
                  if (possibilities[valPos2] == 0){
                    possibilities[valPos2] = round;
                    doneSomething = true;
                  }
                }
              }
              if (doneSomething){
                if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_PAIR_SECTION, valIndex+1, sectionToCell(section,si1)));
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  
 
  var mark = function(position, round, value){
    if (solution[position] != 0) throw ("Marking position that already has been marked.");
    if (solutionRound[position] !=0) throw ("Marking position that was marked another round.");
    var valIndex = value-1;
    solution[position] = value;
  
    var possInd = getPossibilityIndex(valIndex,position);
    if (possibilities[possInd] != 0) throw ("Marking impossible position.");
  
    
    solutionRound[position] = round;
    var rowStart = cellToRow(position)*qqwing.ROW_COL_SEC_SIZE;
    for (var col=0; col<qqwing.ROW_COL_SEC_SIZE; col++){
      var rowVal=rowStart+col;
      var valPos = getPossibilityIndex(valIndex,rowVal);
      if (possibilities[valPos] == 0){
        possibilities[valPos] = round;
      }
    }
  
    
    var colStart = cellToColumn(position);
    for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
      var colVal=colStart+(qqwing.ROW_COL_SEC_SIZE*i);
      var valPos = getPossibilityIndex(valIndex,colVal);
      if (possibilities[valPos] == 0){
        possibilities[valPos] = round;
      }
    }
  
    
    var secStart = cellToSectionStartCell(position);
    for (var i=0; i<qqwing.GRID_SIZE; i++){
      for (var j=0; j<qqwing.GRID_SIZE; j++){
        var secVal=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
        var valPos = getPossibilityIndex(valIndex,secVal);
        if (possibilities[valPos] == 0){
          possibilities[valPos] = round;
        }
      }
    }
  
    
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos = getPossibilityIndex(valIndex,position);
      if (possibilities[valPos] == 0){
        possibilities[valPos] = round;
      }
    }
  };
  
  var findPositionWithFewestPossibilities = function(){
    var minPossibilities = 10;
    var bestPosition = 0;
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      var position = randomBoardArray[i];
      if (solution[position] == 0){
        var count = 0;
        for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0) count++;
        }
        if (count < minPossibilities){
          minPossibilities = count;
          bestPosition = position;
        }
      }
    }
    return bestPosition;
  };
  
  var handleNakedPairs = function(round){
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      var possibilities = countPossibilities(position);
      if (possibilities == 2){
        var row = cellToRow(position);
        var column = cellToColumn(position);
        var section = cellToSectionStartCell(position);
        for (var position2=position; position2<qqwing.BOARD_SIZE; position2++){
          if (position != position2){
            var possibilities2 = countPossibilities(position2);
            if (possibilities2 == 2 && arePossibilitiesSame(position, position2)){
              if (row == cellToRow(position2)){
                var doneSomething = false;
                for (var column2=0; column2<qqwing.ROW_COL_SEC_SIZE; column2++){
                  var position3 = rowColumnToCell(row,column2);
                  if (position3 != position && position3 != position2 && removePossibilitiesInOneFromTwo(position, position3, round)){
                    doneSomething = true;
                  }
                }
                if (doneSomething){
                  if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.NAKED_PAIR_ROW, 0, position));
                  return true;
                }
              }
              if (column == cellToColumn(position2)){
                var doneSomething = false;
                for (var row2=0; row2<qqwing.ROW_COL_SEC_SIZE; row2++){
                  var position3 = rowColumnToCell(row2,column);
                  if (position3 != position && position3 != position2 && removePossibilitiesInOneFromTwo(position, position3, round)){
                    doneSomething = true;
                  }
                }
                if (doneSomething){
                  if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.NAKED_PAIR_COLUMN, 0, position));
                  return true;
                }
              }
              if (section == cellToSectionStartCell(position2)){
                var doneSomething = false;
                var secStart = cellToSectionStartCell(position);
                for (var i=0; i<qqwing.GRID_SIZE; i++){
                  for (var j=0; j<qqwing.GRID_SIZE; j++){
                    var position3=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
                    if (position3 != position && position3 != position2 && removePossibilitiesInOneFromTwo(position, position3, round)){
                      doneSomething = true;
                    }
                  }
                }
                if (doneSomething){
                  if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.NAKED_PAIR_SECTION, 0, position));
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var countPossibilities = function(position){
    var count = 0;
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos = getPossibilityIndex(valIndex,position);
      if (possibilities[valPos] == 0) count++;
    }
    return count;
  };
  
  var arePossibilitiesSame = function(position1, position2){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos1 = getPossibilityIndex(valIndex,position1);
      var valPos2 = getPossibilityIndex(valIndex,position2);
      if ((possibilities[valPos1] == 0 || possibilities[valPos2] == 0) && (possibilities[valPos1] != 0 || possibilities[valPos2] != 0)){
          return false;
      }
    }
    return true;
  };
  
  var addHistoryItem = function(l){
    if (logHistory) l.print();
    if (recordHistory){
      solveHistory.push(l);
      solveInstructions.push(l);
    }
  };
  
  var shuffleRandomArrays = function(){
    shuffleArray(randomBoardArray, qqwing.BOARD_SIZE);
    shuffleArray(randomPossibilityArray, qqwing.ROW_COL_SEC_SIZE);
  };
  
 
  var print = function(puz){
    printnoln(sudokuToString.call(this, puz));
  };
  
  var sudokuToString = function(puz){
    var s = "";
    for(var i=0; i<qqwing.BOARD_SIZE; i++){
      if (printStyle == qqwing.PrintStyle.READABLE){
        s += " ";
      }
      if (puz[i]==0){
        s += '.';
      } else {
        s += puz[i];
      }
      if (i == qqwing.BOARD_SIZE-1){
        if (printStyle == qqwing.PrintStyle.CSV){
          s += ",";
        } else {
          s += "\n";
        }
        if (printStyle == qqwing.PrintStyle.READABLE || printStyle == qqwing.PrintStyle.COMPACT){
          s += "\n";
        }
      } else if (i%qqwing.ROW_COL_SEC_SIZE==qqwing.ROW_COL_SEC_SIZE-1){
        if (printStyle == qqwing.PrintStyle.READABLE || printStyle == qqwing.PrintStyle.COMPACT){
          s += "\n";
        }
        if (i%qqwing.SEC_GROUP_SIZE==qqwing.SEC_GROUP_SIZE-1){
          if (printStyle == qqwing.PrintStyle.READABLE){
            s += "-------|-------|-------\n";
          }
        }
      } else if (i%qqwing.GRID_SIZE==qqwing.GRID_SIZE-1){
        if (printStyle == qqwing.PrintStyle.READABLE){
          s += " |";
        }
      }
    }
    return s;
  };
  
  var rollbackNonGuesses = function(){
    
    
    for (var i=2; i<=lastSolveRound; i+=2){
      rollbackRound.call(this, i);
    }
  };
  
  var clearPuzzle = function(){
    
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      puzzle[i] = 0;
    }
    reset.call(this);
  };
  
  var printHistory = function(v){
    printnoln(getHistoryString(v));
  };
  
  var getHistoryString = function(v){
    var s = "";
    if (!recordHistory){
      s += "History was not recorded.";
      if (printStyle == qqwing.PrintStyle.CSV){
        s += " -- ";
      } else {
        s += "\n";
      }
    }
    for (var i=0;i<v.length;i++){
      s += i+1 + ". " + v[i].toString();
      if (printStyle == qqwing.PrintStyle.CSV){
        s += " -- ";
      } else {
        s += "\n";
      }
    }
    if (printStyle == qqwing.PrintStyle.CSV){
      s += ",";
    } else {
      s += "\n";
    }
    return s;
  };
  
  var removePossibilitiesInOneFromTwo = function(position1, position2, round){
    var doneSomething = false;
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos1 = getPossibilityIndex(valIndex,position1);
      var valPos2 = getPossibilityIndex(valIndex,position2);
      if (possibilities[valPos1] == 0 && possibilities[valPos2] == 0){
        possibilities[valPos2] = round;
        doneSomething = true;
      }
    }
    return doneSomething;
  };
  
 
  var shuffleArray = function(array, size){
    for (var i=0; i<size; i++){
      var tailSize = size-i;
      var randTailPos = Math.floor(Math.random() * tailSize) + i;
      var temp = array[i];
      array[i] = array[randTailPos];
      array[randTailPos] = temp;
    }
  };
  
  var getRandomSymmetry = function(){
    var rand = Math.floor(Math.random() * 4)
    switch (rand){
      case 0: return qqwing.Symmetry.ROTATE90;
      case 1: return qqwing.Symmetry.ROTATE180;
      case 2: return qqwing.Symmetry.MIRROR;
      case 3: return qqwing.Symmetry.FLIP;
    }
    throw ("Unexpected random value: " + rand);
  };
  
  var getLogCount = function(v, type){
    var count = 0;
    for (var i=0; i<v.length; i++){
      if((v[i]).getType() == type) count++;
    }
    return count;
  };
  this.LogItem = function(r, t, v, p){
   
    var round = r;
  
   
    var type = t;
  
   
    var value = v;
  
   
    var position = p;
  
    this.getRound = function (){
      return round;
    };
  
    this.print = function(){
      println(this.toString());
    };
  
    this.getType = function(){
      return type;
    };
  
    this.getColumn = function(){
      if (position == -1) return -1;
      return cellToColumn(position);
    };
  
    this.getRow = function(){
      if (position == -1) return -1;
      return cellToRow(position);
    }
  
    this.getPosition = function(){
      return position;
    }
  
    this.getValue = function(){
      return value;
    }
  
    this.getDescription = function(){
      switch(this.getType()){
        case qqwing.LogType.GIVEN: return "Mark given";
        case qqwing.LogType.ROLLBACK: return "Roll back round";
        case qqwing.LogType.GUESS: return "Mark guess (start round)";
        case qqwing.LogType.HIDDEN_SINGLE_ROW: return "Mark single possibility for value in row";
        case qqwing.LogType.HIDDEN_SINGLE_COLUMN: return "Mark single possibility for value in column";
        case qqwing.LogType.HIDDEN_SINGLE_SECTION: return "Mark single possibility for value in section";
        case qqwing.LogType.SINGLE: return "Mark only possibility for cell";
        case qqwing.LogType.NAKED_PAIR_ROW: return "Remove possibilities for naked pair in row";
        case qqwing.LogType.NAKED_PAIR_COLUMN: return "Remove possibilities for naked pair in column";
        case qqwing.LogType.NAKED_PAIR_SECTION: return "Remove possibilities for naked pair in section";
        case qqwing.LogType.POINTING_PAIR_TRIPLE_ROW: return "Remove possibilities for row because all values are in one section";
        case qqwing.LogType.POINTING_PAIR_TRIPLE_COLUMN: return "Remove possibilities for column because all values are in one section";
        case qqwing.LogType.ROW_BOX: return "Remove possibilities for section because all values are in one row";
        case qqwing.LogType.COLUMN_BOX: return "Remove possibilities for section because all values are in one column";
        case qqwing.LogType.HIDDEN_PAIR_ROW: return "Remove possibilities from hidden pair in row";
        case qqwing.LogType.HIDDEN_PAIR_COLUMN: return "Remove possibilities from hidden pair in column";
        case qqwing.LogType.HIDDEN_PAIR_SECTION: return "Remove possibilities from hidden pair in section";
        default: return "!!! Performed unknown optimization !!!";
      }
    }
  
    this.toString = function(){
      var s = "Round: " + this.getRound() + " - ";
      s += this.getDescription();
      if (value > 0 || position > -1){
        s += " (";
        var printed = false;
        if (position > -1){
          if (printed) s += " - ";
          s += "Row: " + (cellToRow(position)+1) + " - Column: " + (cellToColumn(position)+1);
          printed = true;
        }
        if (value > 0){
          if (printed) s += " - ";
          s += "Value: " + value;
          printed = true;
        }
        s += ")";
      }
      return s;
    }
  };
  
 
  this.setPuzzle = function(initPuzzle){
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      puzzle[i] = initPuzzle[i];
    }
    return reset.call(this);
  }
  
 
  this.printPuzzle = function(){
    return print.call(this, puzzle);
  }
  
 
  this.getPuzzleString = function(){
    return sudokuToString.call(this, puzzle);
  }
  
 
  this.printSolution = function(){
    return print.call(this, solution);
  }
  
 
  this.getSolutionString = function(){
    return sudokuToString.call(this, solution);
  }
  
  this.solve = function(round){
    if (!round || round <= 1){
      reset.call(this);
      shuffleRandomArrays();
      return this.solve(2);
    }
  
    lastSolveRound = round;
  
    while (singleSolveMove.call(this, round)){
      if (this.isSolved()) return true;
      if (isImpossible.call(this)) return false;
    }
  
    var nextGuessRound = round+1;
    var nextRound = round+2;
    for (var guessNumber=0; guess.call(this, nextGuessRound, guessNumber); guessNumber++){
      if (isImpossible.call(this) || !this.solve(nextRound)){
        rollbackRound.call(this, nextRound);
        rollbackRound.call(this, nextGuessRound);
      } else {
        return true;
      }
    }
    return false;
  };
  
  
  this.countSolutions = function(round, limitToTwo){
    if (!round || round <= 1){
      
      var recHistory = recordHistory;
      this.setRecordHistory(false);
      var lHistory = logHistory;
      this.setLogHistory(false);
  
      reset.call(this);
      var solutionCount = this.countSolutions(2, false);
  
      
      this.setRecordHistory(recHistory);
      this.setLogHistory(lHistory);
  
      return solutionCount;
    } else {
      while (singleSolveMove.call(this, round)){
        if (this.isSolved()){
          rollbackRound.call(this, round);
          return 1;
        }
        if (isImpossible.call(this)){
          rollbackRound.call(this, round);
          return 0;
        }
      }
  
      var solutions = 0;
      var nextRound = round+1;
      for (var guessNumber=0; guess.call(this, nextRound, guessNumber); guessNumber++){
        solutions += this.countSolutions(nextRound, limitToTwo);
        if (limitToTwo && solutions >=2){
          rollbackRound.call(this, round);
          return solutions;
        }
      }
      rollbackRound.call(this, round);
      return solutions;
    }
  };
  
  this.isSolved = function(){
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (solution[i] == 0){
        return false;
      }
    }
    return true;
  };
  
  this.getSolveHistory = function(){
    if (this.isSolved()){
      return solveHistory;
    } else {
      return "No solve history - Puzzle is not possible to solve.";
    }
  };
  
  this.getSolveHistoryString = function(){
    if (this.isSolved()){
      return getHistoryString.call(this, solveHistory);
    } else {
      return "No solve history - Puzzle is not possible to solve.";
    }
  };
  
  this.printSolveHistory = function(){
    if (this.isSolved()){
      printHistory(solveHistory);
    } else {
      println("No solve history - Puzzle is not possible to solve.");
    }
  };
  
  this.setRecordHistory = function(recHistory){
    recordHistory = recHistory;
  };
  
  this.setLogHistory = function(logHist){
    logHistory = logHist;
  };
  
  this.setPrintStyle = function(ps){
    printStyle = ps;
  };
  
  this.generatePuzzle = function(){
    return this.generatePuzzleSymmetry(qqwing.Symmetry.NONE);
  };
  
  this.generatePuzzleSymmetry = function(symmetry){
      if (symmetry == qqwing.Symmetry.RANDOM) symmetry = getRandomSymmetry.call(this);
  
      
      var recHistory = recordHistory;
      this.setRecordHistory(false);
      var lHistory = logHistory;
      this.setLogHistory(false);
  
      clearPuzzle.call(this);
  
      
      
      shuffleRandomArrays.call(this);
  
      
      
      
      
      this.solve();
  
      if (symmetry == qqwing.Symmetry.NONE){
        
        
        
        
        rollbackNonGuesses.call(this);
      }
  
      
      
      for (var i=0; i<qqwing.BOARD_SIZE; i++){
        puzzle[i] = solution[i];
      }
  
      
      
      shuffleRandomArrays.call(this);
  
      
      
      
      
      for (var i=0; i<qqwing.BOARD_SIZE; i++){
        
        var position = randomBoardArray[i];
        if (puzzle[position] > 0){
          var positionsym1 = -1;
          var positionsym2 = -1;
          var positionsym3 = -1;
          switch (symmetry){
            case qqwing.Symmetry.ROTATE90:
              positionsym2 = rowColumnToCell(qqwing.ROW_COL_SEC_SIZE-1-cellToColumn(position),cellToRow(position));
              positionsym3 = rowColumnToCell(cellToColumn(position),qqwing.ROW_COL_SEC_SIZE-1-cellToRow(position));
            case qqwing.Symmetry.ROTATE180:
              positionsym1 = rowColumnToCell(qqwing.ROW_COL_SEC_SIZE-1-cellToRow(position),qqwing.ROW_COL_SEC_SIZE-1-cellToColumn(position));
            break;
            case qqwing.Symmetry.MIRROR:
              positionsym1 = rowColumnToCell(cellToRow(position),qqwing.ROW_COL_SEC_SIZE-1-cellToColumn(position));
            break;
            case qqwing.Symmetry.FLIP:
              positionsym1 = rowColumnToCell(qqwing.ROW_COL_SEC_SIZE-1-cellToRow(position),cellToColumn(position));
            break;
          }
          
          
          var savedValue = puzzle[position];
          puzzle[position] = 0;
          var savedSym1 = 0;
          if (positionsym1 >= 0){
            savedSym1 = puzzle[positionsym1];
            puzzle[positionsym1] = 0;
          }
          var savedSym2 = 0;
          if (positionsym2 >= 0){
            savedSym2 = puzzle[positionsym2];
            puzzle[positionsym2] = 0;
          }
          var savedSym3 = 0;
          if (positionsym3 >= 0){
            savedSym3 = puzzle[positionsym3];
            puzzle[positionsym3] = 0;
          }
          reset.call(this);
          if (this.countSolutions(2, true) > 1){
            
            puzzle[position] = savedValue;
            if (positionsym1 >= 0 && savedSym1 != 0) puzzle[positionsym1] = savedSym1;
            if (positionsym2 >= 0 && savedSym2 != 0) puzzle[positionsym2] = savedSym2;
            if (positionsym3 >= 0 && savedSym3 != 0) puzzle[positionsym3] = savedSym3;
          }
        }
      }
  
      
      reset.call(this);
  
      
      this.setRecordHistory(recHistory);
      this.setLogHistory(lHistory);
  
      return true;
  };
  
 
  this.getGivenCount = function(){
    var count = 0;
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (puzzle[i] != 0) count++;
    }
    return count;
  };
  
 
  this.getSingleCount = function(){
    return getLogCount.call(this, solveInstructions, qqwing.LogType.SINGLE);
  }
  
 
  this.getHiddenSingleCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_SINGLE_ROW) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_SINGLE_COLUMN) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_SINGLE_SECTION)
    );
  };
  
 
  
  this.getNakedPairCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.NAKED_PAIR_ROW) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.NAKED_PAIR_COLUMN) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.NAKED_PAIR_SECTION)
    );
  };
  
 
  this.getHiddenPairCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_PAIR_ROW) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_PAIR_COLUMN) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_PAIR_SECTION)
    );
  };
  
 
  this.getBoxLineReductionCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.ROW_BOX)+
      getLogCount.call(this, solveInstructions, qqwing.LogType.COLUMN_BOX)
    );
  };
  
 
  
  this.getPointingPairTripleCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.POINTING_PAIR_TRIPLE_ROW)+
      getLogCount.call(this, solveInstructions, qqwing.LogType.POINTING_PAIR_TRIPLE_COLUMN)
    );
  };
  
 
  this.getGuessCount = function(){
    return getLogCount.call(this, solveInstructions, qqwing.LogType.GUESS);
  };
  
 
  this.getBacktrackCount = function(){
    return getLogCount.call(this, solveHistory, qqwing.LogType.ROLLBACK);
  };
  
  this.getSolveInstructions = function(){
    if (this.isSolved()){
      return solveInstructions;
    } else {
      return "No solve instructions - Puzzle is not possible to solve.";
    }
  };
  
  this.getSolveInstructionsString = function(){
    if (this.isSolved()){
      return getHistoryString.call(this, solveInstructions);
    } else {
      return "No solve instructions - Puzzle is not possible to solve.";
    }
  };
  
  this.printSolveInstructions = function(){
    if (this.isSolved()){
      printHistory(solveInstructions);
    } else {
      println("No solve instructions - Puzzle is not possible to solve.");
    }
  };
  
  this.getDifficulty = function(){
    if (this.getGuessCount() > 0) return qqwing.Difficulty.EXPERT;
    if (this.getBoxLineReductionCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getPointingPairTripleCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getHiddenPairCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getNakedPairCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getHiddenSingleCount() > 0) return qqwing.Difficulty.EASY;
    if (this.getSingleCount() > 0) return qqwing.Difficulty.SIMPLE;
    return qqwing.Difficulty.UNKNOWN;
  };
  
  this.getDifficultyAsString = function(){
    var difficulty = this.getDifficulty();
    switch (difficulty){
      case qqwing.Difficulty.EXPERT: return "Expert";
      case qqwing.Difficulty.INTERMEDIATE: return "Intermediate";
      case qqwing.Difficulty.EASY: return "Easy";
      case qqwing.Difficulty.SIMPLE: return "Simple";
      default: return "Unknown";
    }
  };
  };
  qqwing.PrintStyle = {
    ONE_LINE: 0,
    COMPACT: 1,
    READABLE: 2,
    CSV: 3
  };
  
  qqwing.Difficulty = {
    UNKNOWN: 0,
    SIMPLE: 1,
    EASY: 2,
    INTERMEDIATE: 3,
    EXPERT: 4
  };
  
  qqwing.Symmetry = {
    NONE: 0,
    ROTATE90: 1,
    ROTATE180: 2,
    MIRROR: 3,
    FLIP: 4,
    RANDOM: 5
  };
  
  qqwing.LogType = {
    GIVEN: 0,
    SINGLE: 1,
    HIDDEN_SINGLE_ROW: 2,
    HIDDEN_SINGLE_COLUMN: 3,
    HIDDEN_SINGLE_SECTION: 4,
    GUESS: 5,
    ROLLBACK: 6,
    NAKED_PAIR_ROW: 7,
    NAKED_PAIR_COLUMN: 8,
    NAKED_PAIR_SECTION: 9,
    POINTING_PAIR_TRIPLE_ROW: 10,
    POINTING_PAIR_TRIPLE_COLUMN: 11,
    ROW_BOX: 12,
    COLUMN_BOX: 13,
    HIDDEN_PAIR_ROW: 14,
    HIDDEN_PAIR_COLUMN: 15,
    HIDDEN_PAIR_SECTION: 16
  };
  
  qqwing.GRID_SIZE = 3;
  qqwing.ROW_COL_SEC_SIZE = qqwing.GRID_SIZE*qqwing.GRID_SIZE;
  qqwing.SEC_GROUP_SIZE = qqwing.ROW_COL_SEC_SIZE*qqwing.GRID_SIZE;
  qqwing.BOARD_SIZE = qqwing.ROW_COL_SEC_SIZE*qqwing.ROW_COL_SEC_SIZE;
  qqwing.POSSIBILITY_SIZE = qqwing.BOARD_SIZE*qqwing.ROW_COL_SEC_SIZE;
  var board = new Array(qqwing.BOARD_SIZE);
  var boardcolors = new Array(qqwing.BOARD_SIZE);
  var possibilities = new Array(qqwing.POSSIBILITY_SIZE);
  var startTime = 0;
  var gameType = "blank";
  var usedHint = false;
  var stats = new Array();
  var qq = new qqwing();
  var hintPosition = -1;
  var hintArray;
  var links = {};
  
  function stringToStats(statString){
    stats = new Array();
    var statList = statString.split("|");
    for (var i=0; i<statList.length; i++){
      var sp = statList[i].split(",");
      if (sp.length > 4){
        stats[sp[0]] = new Stat(sp[0],sp[1],sp[2],sp[3],sp[4],sp.length>5?sp[5]:0);
      }
    }
  }
  
  function init(){
    initStats();
    if (!newUrlGame()) showScreen('title');
  }
  window.onload = init;
  
  function initStats(){
    var c = getCookie("sudokuStats");
    var ar = c.split("||");
    if (ar.length > 0){
      stringToStats(ar[0]);
    }
    fillDifficultySelect();
    if (ar.length > 1){
      var nv = ar[1].split("&");
      for(var i=0; i<nv.length; i++){
        var nvp = nv[i].split("=");
        if (nvp.length==2){
          if (nvp[0]=='diff'){
            setDifficulty(nvp[1]);
          }
        }
      }
    }
    drawStats();
  }
  
  var difficultyLevels = new Array("simple","easy","intermediate","expert","random");
  
  function drawStats(){
    var statsDiv = el("stats");
    var advMsg = "";
    var s = "<table>"
    for (var i=0; i<difficultyLevels.length-1; i++){
      var d = difficultyLevels[i];
      var stat = getStat(d);
      var n = getDiffName(d);
      s+="<tr><th>"+n+"</th><td>"+(stat.besttime?"Best: "+toPrettyTime(stat.besttime)+"<br>":"")+"Solved: "+stat.wincount;
      if (stat.wincount == 0 && d != "expert"){
        s += "<br>You must solve "+d+" puzzles without asking for hints to advance and play more difficult games."
        i=9;
      }
      s+="</td></tr>";
    }
    s+="</table>"
    statsDiv.innerHTML = s;
  }
  
  function haveStats(){
    for (var i=0; i<difficultyLevels.length; i++){
      var d = difficultyLevels[i];
      if (stats[d] != null  && stats[d].time) return true;
    }
    return false;
  }
  
  function fillDifficultySelect(){
    var count = 0;
    var done = false;
    for (var i=0; i<difficultyLevels.length && !done; i++){
      var d = difficultyLevels[i];
      addDifficultyToSelect(d);
      count++;
      if (stats[d] == null || stats[d].wincount == 0) done=true;
    }
    el('difficultyoption').style.display=count>1?'block':'none';
  }
  
  function getDiffName(d){
    return d.substring(0,1).toUpperCase()+d.substring(1,d.length);
  }
  
  function addDifficultyToSelect(d){
    var s = document.gameform.difficultyselect;
    var o = s.options;
    var i;
    for (i=0; i<o.length; i++){
      if (o[i].value == d) return;
    }
    o[i] = new Option(getDiffName(d),d);
    s.selectedIndex=i;
  }
  
  function setDifficulty(d){
    var s = document.gameform.difficultyselect;
    var o = s.options;
    var i;
    for (i=0; i<o.length; i++){
      if (o[i].value == d) s.selectedIndex=i;
    }
  }
  
  function getCookie(name) {
    var prefix = name + "=";
    var begin = document.cookie.indexOf("; " + prefix);
    if (begin == -1) {
      begin = document.cookie.indexOf(prefix);
      if (begin != 0) return "";
    } else begin += 2;
    var end = document.cookie.indexOf(";", begin);
    if (end == -1) end = document.cookie.length;
    return unescape(document.cookie.substring(begin + prefix.length, end));
  }
  
  function statsToString(){
    var s = "";
    for (var i in stats) {
      if(s!="") s+="|";
      s+=stats[i].type+","+stats[i].wincount+","+stats[i].time+","+stats[i].winwithhintcount+","+stats[i].gaveupcount+","+stats[i].besttime;
    }
    return s;
  }
  
  function Stat(type,wincount,time,winwithhintcount,gaveupcount,besttime){
    this.type=type;
    this.wincount=ensureNum(wincount);
    this.time=ensureNum(time);
    this.winwithhintcount=ensureNum(winwithhintcount);
    this.gaveupcount=ensureNum(gaveupcount);
    this.besttime=ensureNum(besttime);
  }
  
  function ensureNum(n){
    if (""+n == "NaN") return 0;
    if (typeof n == 'string') n = parseInt(n);
    return n;
  }
  
  function draw(){
    drawStats();
    determineSquareSize();
    el("game").innerHTML=getFullHtml();
  }
  
  function clickValue(event, cell, value){
    clearHint();
    if ((event.ctrlKey || event.altKey || event.shiftKey) && !isOnlyPossibilityInCell(cell)){
      removePossibility(cell,value);
    } else {
      mark(cell,value,getColor());
    }
    setLink('Everything filled in');
    draw();
    detectComplete();
  }
  
  function clickset(cell){
    clearHint();
    unmark(cell);
    setLink('Everything filled in');
    draw();
  }
  
  function removePossibility(cell, value){
    possibilities[getPossibilityIndex(cell,value-1)] = 1;
  }
  
  function checkPossibility(cell, value){
    var allowed = true;
    var row = cellToRow(cell);
    var column = cellToColumn(cell);
    var section = cellToSection(cell);
    var workingCell;
  
    for (var rowIndex=0; rowIndex<9; rowIndex++){
      workingCell = rowColumnToCell(rowIndex, column);
      if (board[workingCell] == value) allowed = false;
    }
  
    for (var columnIndex=0; columnIndex<9; columnIndex++){
      workingCell = rowColumnToCell(row, columnIndex);
      if (board[workingCell] == value) allowed = false;
    }
  
    for (var offset=0; offset<9; offset++){
      workingCell = sectionToCell(section, offset);
      if (board[workingCell] == value) allowed = false;
    }
  
    possibilities[getPossibilityIndex(cell,value-1)] = allowed?0:1;
  }
  
  function unmark(cell){
    var value = board[cell];
    board[cell] = 0;
    boardcolors[cell] = 0;
    var possibilityIndex;
    var workingCell;
  
    for (var valueIndex = 0; valueIndex<9; valueIndex++){
      checkPossibility(cell, valueIndex+1);
    }
  
    var row = cellToRow(cell);
    var column = cellToColumn(cell);
    var section = cellToSection(cell);
  
    for (var rowIndex=0; rowIndex<9; rowIndex++){
      workingCell = rowColumnToCell(rowIndex, column);
      checkPossibility(workingCell,value);
    }
  
    for (var columnIndex=0; columnIndex<9; columnIndex++){
      workingCell = rowColumnToCell(row, columnIndex);
      checkPossibility(workingCell,value);
    }
  
    for (var offset=0; offset<9; offset++){
      workingCell = sectionToCell(section, offset);
      checkPossibility(workingCell,value);
    }
  }
  
  function mark(cell, value, color){
    board[cell] = value;
    boardcolors[cell] = color;
    var possibilityIndex;
    var workingCell;
  
  
    for (var valueIndex = 0; valueIndex<9; valueIndex++){
      possibilityIndex = getPossibilityIndex(cell,valueIndex);
      if (possibilities[possibilityIndex] == 0){
        possibilities[possibilityIndex] = 1;
      }
    }
  
    var row = cellToRow(cell);
    var column = cellToColumn(cell);
    var section = cellToSection(cell);
  
    for (var rowIndex=0; rowIndex<9; rowIndex++){
      workingCell = rowColumnToCell(rowIndex, column);
      possibilityIndex = getPossibilityIndex(workingCell,value-1);
      if (possibilities[possibilityIndex] == 0){
        possibilities[possibilityIndex] = 1;
      }
    }
  
    for (var columnIndex=0; columnIndex<9; columnIndex++){
      workingCell = rowColumnToCell(row, columnIndex);
      possibilityIndex = getPossibilityIndex(workingCell,value-1);
      if (possibilities[possibilityIndex] == 0){
        possibilities[possibilityIndex] = 1;
      }
    }
  
    for (var offset=0; offset<9; offset++){
      workingCell = sectionToCell(section, offset);
      possibilityIndex = getPossibilityIndex(workingCell,value-1);
      if (possibilities[possibilityIndex] == 0){
        possibilities[possibilityIndex] = 1;
      }
    }
  }
  
  function isOnlyPossibilityInCell(cell){
    var count = 0;
    for (var valueIndex = 0; valueIndex<9; valueIndex++){
      if (possibilities[getPossibilityIndex(cell,valueIndex)]==0) count++;
    }
    return count==1;
  }
  
  function detectComplete(){
    var complete = true;
    for (var cell=0; cell<qqwing.BOARD_SIZE; cell++){
      if (board[cell] == 0) complete = false;
    }
    if (complete && gameType!="complete"){
      var gamet = getGameTime();
      var msg = getDiffName(gameType) + " Sudoku solved in " + toPrettyTime(gamet);
      var s = getStat(gameType);
      if (!usedHint){
        s.wincount++;
        s.time+=gamet;
        if (!s.besttime || gamet < s.besttime){
          s.besttime=gamet;
          msg += "; your best time!";
        }
      } else {
        msg += " although you needed a hint."
        s.winwithhintcount++;
      }
      el('endgamemessage').innerHTML = msg;
      saveStats();
      gameType = "complete";
      usedHint = false;
      pauseTime = 0;
      startTime = new Date().getTime();
      fillDifficultySelect();
      showScreen('over');
      draw();
    }
  }
  
  function getStat(name){
    var s = stats[name];
    if (s == null){
      s = new Stat(name,0,0,0,0);
      stats[name] = s;
    }
    return s;
  }
  
  function getDifficulty(){
    return document.gameform.difficultyselect.value;
  }
  
  function getSymmetry(){
    console.log(document.gameform.symmetryselect.value)
    return document.gameform.symmetryselect.value;
  }
  
  function saveStats(){
    var expires = new Date();
    
    expires.setTime(expires.getTime() + 365 * 24 * 60 * 60 * 1000);
    document.cookie = (
      'sudokuStats' + '=' +
      escape(statsToString() + "||diff=" + getDifficulty()) +
      '; expires=' + expires.toGMTString()
    );
  }
  
  function getGameTime(){
    return ((new Date()).getTime() - startTime - pauseTime);
  }
  
  function toPrettyTime(ms){
    var hours = Math.floor(ms / 3600000);
    ms = ms % 3600000;
    var minutes = Math.floor(ms / 60000);
    ms = ms % 60000;
    var seconds = Math.floor(ms / 1000);
    ms = ms % 1000;
    if (hours > 0){
      return hours + " hour"+((hours!=1)?"s":"")+", "+ minutes + " minute"+((minutes!=1)?"s":"");
    } else if (minutes > 0){
      return minutes + " minute"+((minutes!=1)?"s":"")+", "+ seconds + " second"+((seconds!=1)?"s":"");
    } else {
      return seconds + " second"+((seconds!=1)?"s":"");
    }
  }
  
  function getFullHtml(){
    var s="<table>";
    for (var section=0; section<9; section++){
      if (section%3==0) s+="<tr>";
      s+="<td class=sudokusection>";
      s+=getSectionHtml(section);
      s+=("</td>");
      if (section%3==2) s+="</tr>";
    }
    s+="</table>";
    return s;
  }
  
  var squareSize=0;
  var smallSquareFontSize;
  var largeSquareFontSize;
  function determineSquareSize(){
    var h = getWindowHeight();
    var z = 100000;
    var g = el("testcell");
    var f = 100;
    var lastz = 0;
    while (z > h && z != lastz){
      lastz = z;
      smallSquareFontSize="font-size:"+f+"%;";
      largeSquareFontSize="font-size:"+(3*f)+"%;";
      var s = "";
      s+="<table>";
      for (var valueIndex=0; valueIndex<9; valueIndex++){
        if (valueIndex%3==0) s+="<tr>";
        s+="<td style='font-family:monospace;"+smallSquareFontSize+"'>5</td>";
        if (valueIndex%3==2) s+="</tr>";
      }
      s+="</table>";
      g.innerHTML=s;
      squareSize = g.offsetHeight+4; 
      g.innerHTML="";
      z = squareSize * 10;
      f *= .9;
    }
  }
  
  function getWindowHeight(){
    var myWidth = 0, myHeight = 0;
    if( typeof( window.innerWidth ) == 'number' ) {
      return window.innerHeight;
    } else if( document.documentElement && ( document.documentElement.clientWidth || document.documentElement.clientHeight ) ) {
      return document.documentElement.clientHeight;
    } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
      return document.body.clientHeight;
    }
    return 800;
  }
  
  function getSectionHtml(section){
    var s="<table class=unselectable unselectable=on>";
    for (var offset=0; offset<9; offset++){
      if (offset%3==0) s+="<tr>";
      var cell = sectionToCell(section, offset);
      var hintclass = (cell==hintPosition)?" hintcell":"";
      s+="<td style='width:"+squareSize+"px;height:"+squareSize+"px;' align=center class='cell unselectable"+hintclass+"' unselectable=on>";
      s+=getCellHtml(cell);
      s+="</td>";
      if (offset%3==2) s+="</tr>";
    }
    s+="</table>";
    return s;
  }
  
  function getCellHtml(cell){
    var s = "";
    if (board[cell] == 0){
      var possleft = 0;
      var click = "";
      var s1="<table class=unselectable unselectable=on>";
      for (var valueIndex=0; valueIndex<9; valueIndex++){
        if (valueIndex%3==0) s1+="<tr class=unselectable unselectable=on>";
        var value=valueIndex+1;
        var possibilityIndex = getPossibilityIndex(cell,valueIndex);
        if (possibilities[possibilityIndex]==0){
          click = "onmouseup='clickValue(event,"+cell+","+value+");'";
          s1+="<td "+click+" style='font-family:monospace;cursor:pointer;cursor:hand;"+smallSquareFontSize+"' class=unselectable unselectable=on>";
          s1+=value;
          s1+="</td>";
          possleft++;
        } else {
          s1+="<td style='font-family:monospace;"+smallSquareFontSize+"' class=unselectable unselectable=on>&nbsp;</td>";
        }
        if (valueIndex%3==2) s1+="</tr>";
      }
      s1+="</table>";
      if (possleft > 1){
        s+=s1;
      } else if (possleft == 1){
        s+="<div style='cursor:pointer;cursor:hand' "+click+" class=unselectable unselectable=on>";
        s+=s1;
        s+="</div>";
      } else {
        s+= "<div style='"+largeSquareFontSize+"font-weight:bold;background-color:red;color:orange' class=unselectable unselectable=on>X</div>";
      }
    } else if (boardcolors[cell]){
      s+= "<div style='"+largeSquareFontSize+"font-weight:bold;cursor:pointer;cursor:hand;color:"+boardcolors[cell]+";' onmouseup='clickset("+cell+")' class=unselectable unselectable=on>"+board[cell]+"</div>";
    } else {
      s+= "<div style='"+largeSquareFontSize+"font-weight:bold;' class='unselectable given' unselectable=on>"+board[cell]+"</div>";
    }
    return s;
  
  }
  
  function sectionToFirstCell(section){
    return ((section%3)*3)
        + (Math.floor(section/3)*3*9);
  }
  
  function sectionToCell(section, offset){
    return sectionToFirstCell(section)
        + (Math.floor(offset/3)*9)
        + (offset%3);
  }
  
  function getColor(){
    var r = document.gameform.color;
    for (var i=0; i<r.length; i++){
      if (r[i].checked){
        return r[i].value;
      }
    }
    return "black";
  }
  
  function setColor(c){
    var r = document.gameform.color;
    for (var i=0; i<r.length; i++){
      if (r[i].value == c){
        r[i].checked = true;
      }
    }
  }
  
  function cellToColumn(cell){
    return cell%9;
  }
  
  function cellToRow(cell){
    return Math.floor(cell/9);
  }
  
  function cellToSection(cell){
    return (Math.floor(cell/27)*3)
        + Math.floor(cellToColumn(cell)/3);
  }
  
  function getPossibilityIndex(cell, valueIndex){
    return valueIndex+(9*cell);
  }
  
  function rowColumnToCell(row, column){
    return (row*9)+column;
  }
  
  var generateNewGame = function(){
    qq.generatePuzzleSymmetry(getSymmetry());
    qq.setRecordHistory(true);
    qq.solve();
    var diff = qq.getDifficultyAsString().toLowerCase();
    if ("random" != getDifficulty() && diff != getDifficulty()){
      setTimeout(generateNewGame, 0);
    } else {
      newGame(diff,qq.getPuzzleString());
      el('newgamemessage').innerHTML="";
    }
  }
  
  function newQQwingGame(){
    showScreen('loading');
    var workingImg = document.createElement("img");
    workingImg.src = "loading.gif";
    var msg = el('newgamemessage');
    msg.innerHTML="Loading new game ";
    msg.appendChild(workingImg);
    setTimeout(generateNewGame, 0);
  }
  
  
  function clearHint(){
    hintArray = null;
    hintPosition = -1;
    document.gameform.hintButton.disabled=false;
    document.gameform.hintButton.value='Hint';
    setHint("");
  }
  
  function hint(){
    usedHint = true;
    var hint = "";
    hintPosition = -1;
    if (!hintArray){
      qq.setPuzzle(board);
      qq.setRecordHistory(true);
      qq.solve();
      var instructions = qq.getSolveHistory();
      if (typeof instructions == 'string'){
        hint = instructions;
      } else {
        hintArray = instructions;
      }
    }
    while (!hint && hintArray && hintArray.length){
      var next = hintArray.shift();
      if (!haveUsedHint(next)){
        hint = next.getDescription();
        if (next.getValue() > 0) hint += " - " + next.getValue();
        hintPosition = next.getPosition();
      }
    }
    if (!hintArray || !hintArray.length) {
      document.gameform.hintButton.disabled=true;
    } else if (hint) {
      document.gameform.hintButton.value="More hints";
    }
    setHint(hint);
    draw();
  }
  
  function haveUsedHint(hint){
    switch(hint.getType()){
      case qqwing.LogType.GIVEN:
        return true;
      case qqwing.LogType.NAKED_PAIR_ROW:
        var row = cellToRow(hint.getPosition());
        var cellposs = [];
        for (var valueIndex = 0; valueIndex<9; valueIndex++){
          cellposs[valueIndex] = possibilities[getPossibilityIndex(hint.getPosition(),valueIndex)];
        }
        for (var columnIndex=0; columnIndex<9; columnIndex++){
          workingCell = rowColumnToCell(row, columnIndex);
          var isPartOfPair = true;
          var hasPairPoss = false;
          for (var valueIndex = 0; !board[workingCell] && valueIndex<9; valueIndex++){
            var poss=possibilities[getPossibilityIndex(workingCell,valueIndex)];
            if (cellposs[valueIndex] != poss) isPartOfPair = false;
            if (!cellposs[valueIndex] && !poss) hasPairPoss = true;
          }
          if (!isPartOfPair && hasPairPoss) return false;
        }
        return true;
      case qqwing.LogType.NAKED_PAIR_COLUMN:
        var col = cellToColumn(hint.getPosition());
        var cellposs = [];
        for (var valueIndex = 0; valueIndex<9; valueIndex++){
          cellposs[valueIndex] = possibilities[getPossibilityIndex(hint.getPosition(),valueIndex)];
        }
        for (var rowIndex=0; rowIndex<9; rowIndex++){
          workingCell = rowColumnToCell(rowIndex, col);
          var isPartOfPair = true;
          var hasPairPoss = false;
          for (var valueIndex = 0; !board[workingCell] && valueIndex<9; valueIndex++){
            var poss=possibilities[getPossibilityIndex(workingCell,valueIndex)];
            if (cellposs[valueIndex] != poss) isPartOfPair = false;
            if (!cellposs[valueIndex] && !poss) hasPairPoss = true;
          }
          if (!isPartOfPair && hasPairPoss) return false;
        }
        return true;
      case qqwing.LogType.NAKED_PAIR_SECTION:
        var section = cellToSection(hint.getPosition());
        var cellposs = [];
        for (var valueIndex = 0; valueIndex<9; valueIndex++){
          cellposs[valueIndex] = possibilities[getPossibilityIndex(hint.getPosition(),valueIndex)];
        }
        for (var sectionOffset=0; sectionOffset<9; sectionOffset++){
          workingCell = sectionToCell(section, sectionOffset);
          var isPartOfPair = true;
          var hasPairPoss = false;
          for (var valueIndex = 0; !board[workingCell] && valueIndex<9; valueIndex++){
            var poss=possibilities[getPossibilityIndex(workingCell,valueIndex)];
            if (cellposs[valueIndex] != poss) isPartOfPair = false;
            if (!cellposs[valueIndex] && !poss) hasPairPoss = true;
          }
          if (!isPartOfPair && hasPairPoss) return false;
        }
        return true;
      default:
        return false;
    }
  }
  
  function setHint(s){
    var hintdiv = el('hint');
    hintdiv.innerHTML = s;
    hintdiv.style.display=s?'block':'none';
  }
  
  function clearBoard(){
    recordgaveup();
    clearHint();
    for (var boardindex=0; boardindex<qqwing.BOARD_SIZE; boardindex++) board[boardindex]=0;
    for (var boardcolorsindex=0; boardcolorsindex<qqwing.BOARD_SIZE; boardcolorsindex++) boardcolors[boardcolorsindex]=0;
    for (var possibilitiesindex=0; possibilitiesindex<qqwing.POSSIBILITY_SIZE; possibilitiesindex++) possibilities[possibilitiesindex]=0;
    setLink();
    usedHint = false;
    pauseTime = 0;
    startTime = new Date().getTime();
  }
  
  function clearColor(color){
    clearHint();
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (board[i] != 0 && boardcolors[i] == color){
        unmark(i);
      }
    }
    draw();
  }
  
  function newGame(type, s){
    clearBoard();
    gameType=type;
    showScreen('game');
    var count = 0;
    for (var ca=0; ca<s.length; ca++){
      var c = s.charAt(ca);
      if ((c == '.' || (c >= '0' && c <= '9')) && count < qqwing.BOARD_SIZE){
        if (c >= '1' && c <= '9') mark(count,c-'0',null);
        count++;
      }
    }
    setLink("Link to this game");
    draw();
  }
  
  function setLink(type){
    if (type){
      links[type] = getGameUrl();
    } else {
      links={};
    }
    var s = getLinkHtml('Link to this game') + getLinkHtml('Everything filled in');
    el('gamelinks').innerHTML = s;
    el('ingamelinks').innerHTML = s;
  
  }
  function getLinkHtml(type){
    if (!links[type]) return "";
    var id = type.replace(/ /g,"");
    return '<div><a href="'+ links[type] +'">' + type + '</a>:</div><div onclick="select(this);" class=textlink>' + links[type] + '</div>';
  }
  
  function select(node) {
    var range;
    if (document.selection) {
      range = document.body.createTextRange();
      range.moveToElementText(node);
      range.select();
    } else if (window.getSelection) {
      range = document.createRange();
      range.selectNodeContents(node);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);
    }
  }
  
  
  function getGameUrl(){
    var url = document.location.href;
    if (url.indexOf('?') != -1){
      url = url.substring(0,url.indexOf('?'));
    }
    return url+"?game="+gameToString();
  }
  
  function gameToString(){
    var s = "";
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (board[i] == 0){
        s += '.';
      } else {
        s += board[i];
      }
    }
    return s;
  }
  
  function recordgaveup(){
    var filled = 0;
    for (var cell=0; cell<qqwing.BOARD_SIZE; cell++){
      if (board != null && cell < board.length && board[cell] && board[cell] != 0) filled++;
    }
    if (filled !=0 && filled != qqwing.BOARD_SIZE){
      var s = getStat(gameType);
      s.gaveupcount++;
      saveStats();
    }
  }
  window.onunload=recordgaveup;
  
  function startBlank(){
    newGame('blank','');
    return false;
  }
  
  function newUrlGame(){
    var cgiData = location.search.substring(1,location.search.length);
    var nameValPairs = new Array();
    var newgame = false;
    nameValPairs = cgiData.split('&');
    for (var i=0; i<nameValPairs.length; i++){
      var nameValPair;
      var value;
      if (nameValPairs[i].indexOf('game=') == 0) {
        var game = nameValPairs[i].substring(5);
        newGame('url',game);
        newgame=true;
      }
    }
    return newgame;
  }
  
  var pauseStart = 0;
  var pauseTime = 0;
  var pauseState = "";
  var resumecountdown=5;
  
  function pauseGame(){
    pauseStart = (new Date()).getTime();
    el('elapsedtime').innerHTML = "Game play time: " + toPrettyTime(getGameTime());
    showScreen('pause');
  }
  
  function resumeGame(){
    resumecountdown=5;
    finishResume();
  }
  
  function finishResume(){
    if (resumecountdown > 0){
      el('resumecount').innerHTML = resumecountdown;
      showScreen('resume');
      resumecountdown--;
      setTimeout(finishResume, 1000);
    } else {
      showScreen('game');
      pauseTime += (new Date()).getTime()-pauseStart;
    }
  }
  
  function showScreen(screen){
    el('entiregame').style.display = screen=='game'?'block':'none';
    el('titlescreen').style.display = /title|over/.test(screen)?'block':'none';
    el('pausescreen').style.display = screen=='pause'?'block':'none';
    el('resumescreen').style.display = screen=='resume'?'block':'none';
    el('newgamemessage').style.display = screen=='loading'?'block':'none';
    el('endgamescreen').style.display = screen=='over'?'block':'none';
    console.log(screen + " " + haveStats());
    el('statsarea').style.display = (!/game|loading|resume/.test(screen)&&haveStats())?'block':'none';
    console.log(el('statsarea').style.display);
    el('gamelinks').style.display = 'none';
    el('instructions').style.display='none';
    el('options').style.display='none';
  }
  
  function toggleDisp(id){
    var sty = el(id).style;
    sty.display=sty.display=='block'?'none':'block';
    return false;
  }
  
  function showOptions(){
    var sty = el('options').style;
    sty.display=sty.display=='block'?'none':'block';
  }
  
  function el(elementid){
    return document.getElementById(elementid);
  }
  