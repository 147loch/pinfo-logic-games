var qqwing = function(){

  var cellToColumn = function(cell){
    return cell%qqwing.ROW_COL_SEC_SIZE;
  };
  
  var cellToRow = function(cell){
    return Math.floor(cell/qqwing.ROW_COL_SEC_SIZE);
  };
  
  var cellToSectionStartCell = function(cell){
    return Math.floor(cell/qqwing.SEC_GROUP_SIZE)*qqwing.SEC_GROUP_SIZE
        + Math.floor(cellToColumn(cell)/qqwing.GRID_SIZE)*qqwing.GRID_SIZE;
  };
  
  var cellToSection = function(cell){
    return Math.floor(cell/qqwing.SEC_GROUP_SIZE)*qqwing.GRID_SIZE
        + Math.floor(cellToColumn(cell)/qqwing.GRID_SIZE);
  };
  
  var rowToFirstCell = function(row){
    return qqwing.ROW_COL_SEC_SIZE*row;
  };
  
  var columnToFirstCell = function(column){
    return column;
  };
  
  var sectionToFirstCell = function(section){
    return (section%qqwing.GRID_SIZE*qqwing.GRID_SIZE) + Math.floor(section/qqwing.GRID_SIZE)*qqwing.SEC_GROUP_SIZE;
  };
  
  var getPossibilityIndex = function(valueIndex, cell){
    return valueIndex+(qqwing.ROW_COL_SEC_SIZE*cell);
  };
  
  var rowColumnToCell = function(row, column){
    return (row*qqwing.ROW_COL_SEC_SIZE)+column;
  };
  
  var sectionToCell = function(section, offset){
    return sectionToFirstCell(section)
        + Math.floor(offset/qqwing.GRID_SIZE)*qqwing.ROW_COL_SEC_SIZE
        + (offset%qqwing.GRID_SIZE);
  };
  
  var println = function(s){
    if ((typeof console != 'undefined') && console.log) console.log(s);
  };
  
  var printnoln = function(s){
    if ((typeof process != 'undefined') && process.stdout && process.stdout.write) process.stdout.write(s);
    else println(s);
  };
  
  var puzzle = new Array(qqwing.BOARD_SIZE);
  
  var solution = new Array(qqwing.BOARD_SIZE);
  
  var solutionRound = new Array(qqwing.BOARD_SIZE);
  
  var possibilities = new Array(qqwing.POSSIBILITY_SIZE);
  
  var randomBoardArray = new Array(qqwing.BOARD_SIZE);
  
  for (var i=0; i<qqwing.BOARD_SIZE; i++){
    randomBoardArray[i] = i;
  }
  
  var randomPossibilityArray = new Array(qqwing.ROW_COL_SEC_SIZE);
  
  for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
    randomPossibilityArray[i] = i;
  }
  
  var recordHistory = false;
  
  var logHistory = false;
  
  var solveHistory = [];
  
  var solveInstructions = [];
  
  var printStyle = qqwing.PrintStyle.READABLE;
  
  var lastSolveRound = 0;
  
  var reset = function(){
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      solution[i] = 0;
    }
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      solutionRound[i] = 0;
    }
    for (var i=0; i<qqwing.POSSIBILITY_SIZE; i++){
      possibilities[i] = 0;
    }
    solveHistory = [];
    solveInstructions = [];
  
    var round = 1;
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      if (puzzle[position] > 0){
        var valIndex = puzzle[position]-1;
        var valPos = getPossibilityIndex(valIndex,position);
        var value = puzzle[position];
        if (possibilities[valPos] != 0) return false;
        mark.call(this,position,round,value);
        if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.GIVEN, value, position));
      }
    }
    return true;
  };
  
  var singleSolveMove = function(round){
    if (onlyPossibilityForCell.call(this, round)) return true;
    if (onlyValueInSection.call(this, round)) return true;
    if (onlyValueInRow.call(this, round)) return true;
    if (onlyValueInColumn.call(this, round)) return true;
    if (handleNakedPairs.call(this, round)) return true;
    if (pointingRowReduction.call(this, round)) return true;
    if (pointingColumnReduction.call(this, round)) return true;
    if (rowBoxReduction.call(this, round)) return true;
    if (colBoxReduction.call(this, round)) return true;
    if (hiddenPairInRow.call(this, round)) return true;
    if (hiddenPairInColumn.call(this, round)) return true;
    if (hiddenPairInSection.call(this, round)) return true;
    return false;
  };
  
  var onlyPossibilityForCell = function(round){
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      if (solution[position] == 0){
        var count = 0;
        var lastValue = 0;
        for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            count++;
            lastValue=valIndex+1;
          }
        }
        if (count == 1){
          mark.call(this, position, round, lastValue);
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.SINGLE, lastValue, position));
          return true;
        }
      }
    }
    return false;
  };
  
  var onlyValueInRow = function(round){
    for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var count = 0;
        var lastPosition = 0;
        for (var col=0; col<qqwing.ROW_COL_SEC_SIZE; col++){
          var position = (row*qqwing.ROW_COL_SEC_SIZE)+col;
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            count++;
            lastPosition = position;
          }
        }
        if (count == 1){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_SINGLE_ROW, value, lastPosition));
          mark.call(this, lastPosition, round, value);
          return true;
        }
      }
    }
    return false;
  }
  
  var onlyValueInColumn = function(round){
    for (var col=0; col<qqwing.ROW_COL_SEC_SIZE; col++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var count = 0;
        var lastPosition = 0;
        for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
          var position = rowColumnToCell(row,col);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            count++;
            lastPosition = position;
          }
        }
        if (count == 1){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_SINGLE_COLUMN, value, lastPosition));
          mark.call(this, lastPosition, round, value);
          return true;
        }
      }
    }
    return false;
  }
  
  
  var onlyValueInSection = function(round){
    for (var sec=0; sec<qqwing.ROW_COL_SEC_SIZE; sec++){
      var secPos = sectionToFirstCell(sec);
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var count = 0;
        var lastPosition = 0;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var position = secPos + i + qqwing.ROW_COL_SEC_SIZE*j;
            var valPos = getPossibilityIndex(valIndex,position);
            if (possibilities[valPos] == 0){
              count++;
              lastPosition = position;
            }
          }
        }
        if (count == 1){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_SINGLE_SECTION, value, lastPosition));
          mark.call(this, lastPosition, round, value);
          return true;
        }
      }
    }
    return false;
  }
  
  var guess = function(round, guessNumber){
    var localGuessCount = 0;
    var position = findPositionWithFewestPossibilities.call(this);
    for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
      var valIndex = randomPossibilityArray[i];
      var valPos = getPossibilityIndex(valIndex,position);
      if (possibilities[valPos] == 0){
        if (localGuessCount == guessNumber){
          var value = valIndex+1;
          if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.GUESS, value, position));
          mark.call(this, position, round, value);
          return true;
        }
        localGuessCount++;
      }
    }
    return false;
  };
  
  var isImpossible = function(){
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      if (solution[position] == 0){
        var count = 0;
        for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0) count++;
        }
        if (count == 0) {
          return true;
        }
      }
    }
    return false;
  };
  
  var rollbackRound = function(round){
    if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.ROLLBACK));
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (solutionRound[i] == round){
        solutionRound[i] = 0;
        solution[i] = 0;
      }
    }
    {for (var i=0; i<qqwing.POSSIBILITY_SIZE; i++){
      if (possibilities[i] == round){
        possibilities[i] = 0;
      }
    }}
  
    while(solveInstructions.length > 0 && solveInstructions[solveInstructions.length-1] == round){
      solveInstructions.pop();
    }
  };
  
  var pointingRowReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var section=0; section<qqwing.ROW_COL_SEC_SIZE; section++){
        var secStart = sectionToFirstCell(section);
        var inOneRow = true;
        var boxRow = -1;
        for (var j=0; j<qqwing.GRID_SIZE; j++){
          for (var i=0; i<qqwing.GRID_SIZE; i++){
            var secVal=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
            var valPos = getPossibilityIndex(valIndex,secVal);
            if(possibilities[valPos] == 0){
              if (boxRow == -1 || boxRow == j){
                boxRow = j;
              } else {
                inOneRow = false;
              }
            }
          }
        }
        if (inOneRow && boxRow != -1){
          var doneSomething = false;
          var row = cellToRow(secStart) + boxRow;
          var rowStart = rowToFirstCell(row);
  
          for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
            var position = rowStart+i;
            var section2 = cellToSection(position);
            var valPos = getPossibilityIndex(valIndex,position);
            if (section != section2 && possibilities[valPos] == 0){
              possibilities[valPos] = round;
              doneSomething = true;
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.POINTING_PAIR_TRIPLE_ROW, valIndex+1, rowStart));
            return true;
          }
        }
      }
    }
    return false;
  };
  
  var rowBoxReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
        var rowStart = rowToFirstCell(row);
        var inOneBox = true;
        var rowBox = -1;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var column = i*qqwing.GRID_SIZE+j;
            var position = rowColumnToCell(row, column);
            var valPos = getPossibilityIndex(valIndex,position);
            if(possibilities[valPos] == 0){
              if (rowBox == -1 || rowBox == i){
                rowBox = i;
              } else {
                inOneBox = false;
              }
            }
          }
        }
        if (inOneBox && rowBox != -1){
          var doneSomething = false;
          var column = qqwing.GRID_SIZE*rowBox;
          var secStart = cellToSectionStartCell(rowColumnToCell(row, column));
          var secStartRow = cellToRow(secStart);
          var secStartCol = cellToColumn(secStart);
          for (var i=0; i<qqwing.GRID_SIZE; i++){
            for (var j=0; j<qqwing.GRID_SIZE; j++){
              var row2 = secStartRow+i;
              var col2 = secStartCol+j;
              var position = rowColumnToCell(row2, col2);
              var valPos = getPossibilityIndex(valIndex,position);
              if (row != row2 && possibilities[valPos] == 0){
                possibilities[valPos] = round;
                doneSomething = true;
              }
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.ROW_BOX, valIndex+1, rowStart));
            return true;
          }
        }
      }
    }
    return false;
  };
  
  var colBoxReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
        var rowStart = rowToFirstCell(row);
        var inOneBox = true;
        var rowBox = -1;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var column = i*qqwing.GRID_SIZE+j;
            var position = rowColumnToCell(row, column);
            var valPos = getPossibilityIndex(valIndex,position);
            if(possibilities[valPos] == 0){
              if (rowBox == -1 || rowBox == i){
                rowBox = i;
              } else {
                inOneBox = false;
              }
            }
          }
        }
        if (inOneBox && rowBox != -1){
          var doneSomething = false;
          var column = qqwing.GRID_SIZE*rowBox;
          var secStart = cellToSectionStartCell(rowColumnToCell(row, column));
          var secStartRow = cellToRow(secStart);
          var secStartCol = cellToColumn(secStart);
          for (var i=0; i<qqwing.GRID_SIZE; i++){
            for (var j=0; j<qqwing.GRID_SIZE; j++){
              var row2 = secStartRow+i;
              var col2 = secStartCol+j;
              var position = rowColumnToCell(row2, col2);
              var valPos = getPossibilityIndex(valIndex,position);
              if (row != row2 && possibilities[valPos] == 0){
                possibilities[valPos] = round;
                doneSomething = true;
              }
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.ROW_BOX, valIndex+1, rowStart));
            return true;
          }
        }
      }
    }
    return false;
  };
  
  var pointingColumnReduction = function(round){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      for (var section=0; section<qqwing.ROW_COL_SEC_SIZE; section++){
        var secStart = sectionToFirstCell(section);
        var inOneCol = true;
        var boxCol = -1;
        for (var i=0; i<qqwing.GRID_SIZE; i++){
          for (var j=0; j<qqwing.GRID_SIZE; j++){
            var secVal=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
            var valPos = getPossibilityIndex(valIndex,secVal);
            if(possibilities[valPos] == 0){
              if (boxCol == -1 || boxCol == i){
                boxCol = i;
              } else {
                inOneCol = false;
              }
            }
          }
        }
        if (inOneCol && boxCol != -1){
          var doneSomething = false;
          var col = cellToColumn(secStart) + boxCol;
          var colStart = columnToFirstCell(col);
  
          for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
            var position = colStart+(qqwing.ROW_COL_SEC_SIZE*i);
            var section2 = cellToSection(position);
            var valPos = getPossibilityIndex(valIndex,position);
            if (section != section2 && possibilities[valPos] == 0){
              possibilities[valPos] = round;
              doneSomething = true;
            }
          }
          if (doneSomething){
            if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.POINTING_PAIR_TRIPLE_COLUMN, valIndex+1, colStart));
            return true;
          }
        }
      }
    }
    return false;
  }
  
  var hiddenPairInRow = function(round){
    for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var c1 = -1;
        var c2 = -1;
        var valCount = 0;
        for (var column=0; column<qqwing.ROW_COL_SEC_SIZE; column++){
          var position = rowColumnToCell(row,column);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            if (c1 == -1 || c1 == column){
              c1 = column;
            } else if (c2 == -1 || c2 == column){
              c2 = column;
            }
            valCount++;
          }
        }
        if (valCount==2){
          for (var valIndex2=valIndex+1; valIndex2<qqwing.ROW_COL_SEC_SIZE; valIndex2++){
            var c3 = -1;
            var c4 = -1;
            var valCount2 = 0;
            for (var column=0; column<qqwing.ROW_COL_SEC_SIZE; column++){
              var position = rowColumnToCell(row,column);
              var valPos = getPossibilityIndex(valIndex2,position);
              if (possibilities[valPos] == 0){
                if (c3 == -1 || c3 == column){
                  c3 = column;
                } else if (c4 == -1 || c4 == column){
                  c4 = column;
                }
                valCount2++;
              }
            }
            if (valCount2==2 && c1==c3 && c2==c4){
              var doneSomething = false;
              for (var valIndex3=0; valIndex3<qqwing.ROW_COL_SEC_SIZE; valIndex3++){
                if (valIndex3 != valIndex && valIndex3 != valIndex2){
                  var position1 = rowColumnToCell(row,c1);
                  var position2 = rowColumnToCell(row,c2);
                  var valPos1 = getPossibilityIndex(valIndex3,position1);
                  var valPos2 = getPossibilityIndex(valIndex3,position2);
                  if (possibilities[valPos1] == 0){
                    possibilities[valPos1] = round;
                    doneSomething = true;
                  }
                  if (possibilities[valPos2] == 0){
                    possibilities[valPos2] = round;
                    doneSomething = true;
                  }
                }
              }
              if (doneSomething){
                if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_PAIR_ROW, valIndex+1, rowColumnToCell(row,c1)));
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var hiddenPairInColumn = function(round){
    for (var column=0; column<qqwing.ROW_COL_SEC_SIZE; column++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var r1 = -1;
        var r2 = -1;
        var valCount = 0;
        for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
          var position = rowColumnToCell(row,column);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            if (r1 == -1 || r1 == row){
              r1 = row;
            } else if (r2 == -1 || r2 == row){
              r2 = row;
            }
            valCount++;
          }
        }
        if (valCount==2){
          for (var valIndex2=valIndex+1; valIndex2<qqwing.ROW_COL_SEC_SIZE; valIndex2++){
            var r3 = -1;
            var r4 = -1;
            var valCount2 = 0;
            for (var row=0; row<qqwing.ROW_COL_SEC_SIZE; row++){
              var position = rowColumnToCell(row,column);
              var valPos = getPossibilityIndex(valIndex2,position);
              if (possibilities[valPos] == 0){
                if (r3 == -1 || r3 == row){
                  r3 = row;
                } else if (r4 == -1 || r4 == row){
                  r4 = row;
                }
                valCount2++;
              }
            }
            if (valCount2==2 && r1==r3 && r2==r4){
              var doneSomething = false;
              for (var valIndex3=0; valIndex3<qqwing.ROW_COL_SEC_SIZE; valIndex3++){
                if (valIndex3 != valIndex && valIndex3 != valIndex2){
                  var position1 = rowColumnToCell(r1,column);
                  var position2 = rowColumnToCell(r2,column);
                  var valPos1 = getPossibilityIndex(valIndex3,position1);
                  var valPos2 = getPossibilityIndex(valIndex3,position2);
                  if (possibilities[valPos1] == 0){
                    possibilities[valPos1] = round;
                    doneSomething = true;
                  }
                  if (possibilities[valPos2] == 0){
                    possibilities[valPos2] = round;
                    doneSomething = true;
                  }
                }
              }
              if (doneSomething){
                if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_PAIR_COLUMN, valIndex+1, rowColumnToCell(r1,column)));
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var hiddenPairInSection = function(round){
    for (var section=0; section<qqwing.ROW_COL_SEC_SIZE; section++){
      for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
        var si1 = -1;
        var si2 = -1;
        var valCount = 0;
        for (var secInd=0; secInd<qqwing.ROW_COL_SEC_SIZE; secInd++){
          var position = sectionToCell(section,secInd);
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0){
            if (si1 == -1 || si1 == secInd){
              si1 = secInd;
            } else if (si2 == -1 || si2 == secInd){
              si2 = secInd;
            }
            valCount++;
          }
        }
        if (valCount==2){
          for (var valIndex2=valIndex+1; valIndex2<qqwing.ROW_COL_SEC_SIZE; valIndex2++){
            var si3 = -1;
            var si4 = -1;
            var valCount2 = 0;
            for (var secInd=0; secInd<qqwing.ROW_COL_SEC_SIZE; secInd++){
              var position = sectionToCell(section,secInd);
              var valPos = getPossibilityIndex(valIndex2,position);
              if (possibilities[valPos] == 0){
                if (si3 == -1 || si3 == secInd){
                  si3 = secInd;
                } else if (si4 == -1 || si4 == secInd){
                  si4 = secInd;
                }
                valCount2++;
              }
            }
            if (valCount2==2 && si1==si3 && si2==si4){
              var doneSomething = false;
              for (var valIndex3=0; valIndex3<qqwing.ROW_COL_SEC_SIZE; valIndex3++){
                if (valIndex3 != valIndex && valIndex3 != valIndex2){
                  var position1 = sectionToCell(section,si1);
                  var position2 = sectionToCell(section,si2);
                  var valPos1 = getPossibilityIndex(valIndex3,position1);
                  var valPos2 = getPossibilityIndex(valIndex3,position2);
                  if (possibilities[valPos1] == 0){
                    possibilities[valPos1] = round;
                    doneSomething = true;
                  }
                  if (possibilities[valPos2] == 0){
                    possibilities[valPos2] = round;
                    doneSomething = true;
                  }
                }
              }
              if (doneSomething){
                if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.HIDDEN_PAIR_SECTION, valIndex+1, sectionToCell(section,si1)));
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var mark = function(position, round, value){
    if (solution[position] != 0) throw ("Marking position that already has been marked.");
    if (solutionRound[position] !=0) throw ("Marking position that was marked another round.");
    var valIndex = value-1;
    solution[position] = value;
  
    var possInd = getPossibilityIndex(valIndex,position);
    if (possibilities[possInd] != 0) throw ("Marking impossible position.");
  
    
    solutionRound[position] = round;
    var rowStart = cellToRow(position)*qqwing.ROW_COL_SEC_SIZE;
    for (var col=0; col<qqwing.ROW_COL_SEC_SIZE; col++){
      var rowVal=rowStart+col;
      var valPos = getPossibilityIndex(valIndex,rowVal);
      if (possibilities[valPos] == 0){
        possibilities[valPos] = round;
      }
    }
  
    
    var colStart = cellToColumn(position);
    for (var i=0; i<qqwing.ROW_COL_SEC_SIZE; i++){
      var colVal=colStart+(qqwing.ROW_COL_SEC_SIZE*i);
      var valPos = getPossibilityIndex(valIndex,colVal);
      if (possibilities[valPos] == 0){
        possibilities[valPos] = round;
      }
    }
  
    
    var secStart = cellToSectionStartCell(position);
    for (var i=0; i<qqwing.GRID_SIZE; i++){
      for (var j=0; j<qqwing.GRID_SIZE; j++){
        var secVal=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
        var valPos = getPossibilityIndex(valIndex,secVal);
        if (possibilities[valPos] == 0){
          possibilities[valPos] = round;
        }
      }
    }
  
    
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos = getPossibilityIndex(valIndex,position);
      if (possibilities[valPos] == 0){
        possibilities[valPos] = round;
      }
    }
  };
  
  var findPositionWithFewestPossibilities = function(){
    var minPossibilities = 10;
    var bestPosition = 0;
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      var position = randomBoardArray[i];
      if (solution[position] == 0){
        var count = 0;
        for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
          var valPos = getPossibilityIndex(valIndex,position);
          if (possibilities[valPos] == 0) count++;
        }
        if (count < minPossibilities){
          minPossibilities = count;
          bestPosition = position;
        }
      }
    }
    return bestPosition;
  };
  
  var handleNakedPairs = function(round){
    for (var position=0; position<qqwing.BOARD_SIZE; position++){
      var possibilities = countPossibilities(position);
      if (possibilities == 2){
        var row = cellToRow(position);
        var column = cellToColumn(position);
        var section = cellToSectionStartCell(position);
        for (var position2=position; position2<qqwing.BOARD_SIZE; position2++){
          if (position != position2){
            var possibilities2 = countPossibilities(position2);
            if (possibilities2 == 2 && arePossibilitiesSame(position, position2)){
              if (row == cellToRow(position2)){
                var doneSomething = false;
                for (var column2=0; column2<qqwing.ROW_COL_SEC_SIZE; column2++){
                  var position3 = rowColumnToCell(row,column2);
                  if (position3 != position && position3 != position2 && removePossibilitiesInOneFromTwo(position, position3, round)){
                    doneSomething = true;
                  }
                }
                if (doneSomething){
                  if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.NAKED_PAIR_ROW, 0, position));
                  return true;
                }
              }
              if (column == cellToColumn(position2)){
                var doneSomething = false;
                for (var row2=0; row2<qqwing.ROW_COL_SEC_SIZE; row2++){
                  var position3 = rowColumnToCell(row2,column);
                  if (position3 != position && position3 != position2 && removePossibilitiesInOneFromTwo(position, position3, round)){
                    doneSomething = true;
                  }
                }
                if (doneSomething){
                  if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.NAKED_PAIR_COLUMN, 0, position));
                  return true;
                }
              }
              if (section == cellToSectionStartCell(position2)){
                var doneSomething = false;
                var secStart = cellToSectionStartCell(position);
                for (var i=0; i<qqwing.GRID_SIZE; i++){
                  for (var j=0; j<qqwing.GRID_SIZE; j++){
                    var position3=secStart+i+(qqwing.ROW_COL_SEC_SIZE*j);
                    if (position3 != position && position3 != position2 && removePossibilitiesInOneFromTwo(position, position3, round)){
                      doneSomething = true;
                    }
                  }
                }
                if (doneSomething){
                  if (logHistory || recordHistory) addHistoryItem.call(this, new this.LogItem(round, qqwing.LogType.NAKED_PAIR_SECTION, 0, position));
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  };
  
  var countPossibilities = function(position){
    var count = 0;
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos = getPossibilityIndex(valIndex,position);
      if (possibilities[valPos] == 0) count++;
    }
    return count;
  };
  
  var arePossibilitiesSame = function(position1, position2){
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos1 = getPossibilityIndex(valIndex,position1);
      var valPos2 = getPossibilityIndex(valIndex,position2);
      if ((possibilities[valPos1] == 0 || possibilities[valPos2] == 0) && (possibilities[valPos1] != 0 || possibilities[valPos2] != 0)){
          return false;
      }
    }
    return true;
  };
  
  var addHistoryItem = function(l){
    if (logHistory) l.print();
    if (recordHistory){
      solveHistory.push(l);
      solveInstructions.push(l);
    }
  };
  
  var shuffleRandomArrays = function(){
    shuffleArray(randomBoardArray, qqwing.BOARD_SIZE);
    shuffleArray(randomPossibilityArray, qqwing.ROW_COL_SEC_SIZE);
  };
  
  var print = function(puz){
    printnoln(sudokuToString.call(this, puz));
  };
  
  var sudokuToString = function(puz){
    var s = "";
    for(var i=0; i<qqwing.BOARD_SIZE; i++){
      if (printStyle == qqwing.PrintStyle.READABLE){
        s += " ";
      }
      if (puz[i]==0){
        s += '.';
      } else {
        s += puz[i];
      }
      if (i == qqwing.BOARD_SIZE-1){
        if (printStyle == qqwing.PrintStyle.CSV){
          s += ",";
        } else {
          s += "\n";
        }
        if (printStyle == qqwing.PrintStyle.READABLE || printStyle == qqwing.PrintStyle.COMPACT){
          s += "\n";
        }
      } else if (i%qqwing.ROW_COL_SEC_SIZE==qqwing.ROW_COL_SEC_SIZE-1){
        if (printStyle == qqwing.PrintStyle.READABLE || printStyle == qqwing.PrintStyle.COMPACT){
          s += "\n";
        }
        if (i%qqwing.SEC_GROUP_SIZE==qqwing.SEC_GROUP_SIZE-1){
          if (printStyle == qqwing.PrintStyle.READABLE){
            s += "-------|-------|-------\n";
          }
        }
      } else if (i%qqwing.GRID_SIZE==qqwing.GRID_SIZE-1){
        if (printStyle == qqwing.PrintStyle.READABLE){
          s += " |";
        }
      }
    }
    return s;
  };
  
  var rollbackNonGuesses = function(){
    
    
    for (var i=2; i<=lastSolveRound; i+=2){
      rollbackRound.call(this, i);
    }
  };
  
  var clearPuzzle = function(){
    
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      puzzle[i] = 0;
    }
    reset.call(this);
  };
  
  var printHistory = function(v){
    printnoln(getHistoryString(v));
  };
  
  var getHistoryString = function(v){
    var s = "";
    if (!recordHistory){
      s += "History was not recorded.";
      if (printStyle == qqwing.PrintStyle.CSV){
        s += " -- ";
      } else {
        s += "\n";
      }
    }
    for (var i=0;i<v.length;i++){
      s += i+1 + ". " + v[i].toString();
      if (printStyle == qqwing.PrintStyle.CSV){
        s += " -- ";
      } else {
        s += "\n";
      }
    }
    if (printStyle == qqwing.PrintStyle.CSV){
      s += ",";
    } else {
      s += "\n";
    }
    return s;
  };
  
  var removePossibilitiesInOneFromTwo = function(position1, position2, round){
    var doneSomething = false;
    for (var valIndex=0; valIndex<qqwing.ROW_COL_SEC_SIZE; valIndex++){
      var valPos1 = getPossibilityIndex(valIndex,position1);
      var valPos2 = getPossibilityIndex(valIndex,position2);
      if (possibilities[valPos1] == 0 && possibilities[valPos2] == 0){
        possibilities[valPos2] = round;
        doneSomething = true;
      }
    }
    return doneSomething;
  };
  
  var shuffleArray = function(array, size){
    for (var i=0; i<size; i++){
      var tailSize = size-i;
      var randTailPos = Math.floor(Math.random() * tailSize) + i;
      var temp = array[i];
      array[i] = array[randTailPos];
      array[randTailPos] = temp;
    }
  };
  
  var getRandomSymmetry = function(){
    var rand = Math.floor(Math.random() * 4)
    switch (rand){
      case 0: return qqwing.Symmetry.ROTATE90;
      case 1: return qqwing.Symmetry.ROTATE180;
      case 2: return qqwing.Symmetry.MIRROR;
      case 3: return qqwing.Symmetry.FLIP;
    }
    throw ("Unexpected random value: " + rand);
  };
  
  var getLogCount = function(v, type){
    var count = 0;
    for (var i=0; i<v.length; i++){
      if((v[i]).getType() == type) count++;
    }
    return count;
  };
  this.LogItem = function(r, t, v, p){

    var round = r;
  

    var type = t;
  

    var value = v;
  

    var position = p;
  
    this.getRound = function (){
      return round;
    };
  
    this.print = function(){
      println(this.toString());
    };
  
    this.getType = function(){
      return type;
    };
  
    this.getColumn = function(){
      if (position == -1) return -1;
      return cellToColumn(position);
    };
  
    this.getRow = function(){
      if (position == -1) return -1;
      return cellToRow(position);
    }
  
    this.getPosition = function(){
      return position;
    }
  
    this.getValue = function(){
      return value;
    }
  
    this.getDescription = function(){
      switch(this.getType()){
        case qqwing.LogType.GIVEN: return "Mark given";
        case qqwing.LogType.ROLLBACK: return "Roll back round";
        case qqwing.LogType.GUESS: return "Mark guess (start round)";
        case qqwing.LogType.HIDDEN_SINGLE_ROW: return "Mark single possibility for value in row";
        case qqwing.LogType.HIDDEN_SINGLE_COLUMN: return "Mark single possibility for value in column";
        case qqwing.LogType.HIDDEN_SINGLE_SECTION: return "Mark single possibility for value in section";
        case qqwing.LogType.SINGLE: return "Mark only possibility for cell";
        case qqwing.LogType.NAKED_PAIR_ROW: return "Remove possibilities for naked pair in row";
        case qqwing.LogType.NAKED_PAIR_COLUMN: return "Remove possibilities for naked pair in column";
        case qqwing.LogType.NAKED_PAIR_SECTION: return "Remove possibilities for naked pair in section";
        case qqwing.LogType.POINTING_PAIR_TRIPLE_ROW: return "Remove possibilities for row because all values are in one section";
        case qqwing.LogType.POINTING_PAIR_TRIPLE_COLUMN: return "Remove possibilities for column because all values are in one section";
        case qqwing.LogType.ROW_BOX: return "Remove possibilities for section because all values are in one row";
        case qqwing.LogType.COLUMN_BOX: return "Remove possibilities for section because all values are in one column";
        case qqwing.LogType.HIDDEN_PAIR_ROW: return "Remove possibilities from hidden pair in row";
        case qqwing.LogType.HIDDEN_PAIR_COLUMN: return "Remove possibilities from hidden pair in column";
        case qqwing.LogType.HIDDEN_PAIR_SECTION: return "Remove possibilities from hidden pair in section";
        default: return "!!! Performed unknown optimization !!!";
      }
    }
  
    this.toString = function(){
      var s = "Round: " + this.getRound() + " - ";
      s += this.getDescription();
      if (value > 0 || position > -1){
        s += " (";
        var printed = false;
        if (position > -1){
          if (printed) s += " - ";
          s += "Row: " + (cellToRow(position)+1) + " - Column: " + (cellToColumn(position)+1);
          printed = true;
        }
        if (value > 0){
          if (printed) s += " - ";
          s += "Value: " + value;
          printed = true;
        }
        s += ")";
      }
      return s;
    }
  };
  
  this.setPuzzle = function(initPuzzle){
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      puzzle[i] = initPuzzle[i];
    }
    return reset.call(this);
  }
  
  this.printPuzzle = function(){
    return print.call(this, puzzle);
  }
  
  this.getPuzzleString = function(){
    return sudokuToString.call(this, puzzle);
  }
  
  this.printSolution = function(){
    return print.call(this, solution);
  }
  
  this.getSolutionString = function(){
    return sudokuToString.call(this, solution);
  }
  
  this.solve = function(round){
    if (!round || round <= 1){
      reset.call(this);
      shuffleRandomArrays();
      return this.solve(2);
    }
  
    lastSolveRound = round;
  
    while (singleSolveMove.call(this, round)){
      if (this.isSolved()) return true;
      if (isImpossible.call(this)) return false;
    }
  
    var nextGuessRound = round+1;
    var nextRound = round+2;
    for (var guessNumber=0; guess.call(this, nextGuessRound, guessNumber); guessNumber++){
      if (isImpossible.call(this) || !this.solve(nextRound)){
        rollbackRound.call(this, nextRound);
        rollbackRound.call(this, nextGuessRound);
      } else {
        return true;
      }
    }
    return false;
  };
  
  
  this.countSolutions = function(round, limitToTwo){
    if (!round || round <= 1){
      
      var recHistory = recordHistory;
      this.setRecordHistory(false);
      var lHistory = logHistory;
      this.setLogHistory(false);
  
      reset.call(this);
      var solutionCount = this.countSolutions(2, false);
  
      
      this.setRecordHistory(recHistory);
      this.setLogHistory(lHistory);
  
      return solutionCount;
    } else {
      while (singleSolveMove.call(this, round)){
        if (this.isSolved()){
          rollbackRound.call(this, round);
          return 1;
        }
        if (isImpossible.call(this)){
          rollbackRound.call(this, round);
          return 0;
        }
      }
  
      var solutions = 0;
      var nextRound = round+1;
      for (var guessNumber=0; guess.call(this, nextRound, guessNumber); guessNumber++){
        solutions += this.countSolutions(nextRound, limitToTwo);
        if (limitToTwo && solutions >=2){
          rollbackRound.call(this, round);
          return solutions;
        }
      }
      rollbackRound.call(this, round);
      return solutions;
    }
  };
  
  this.isSolved = function(){
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (solution[i] == 0){
        return false;
      }
    }
    return true;
  };
  
  this.getSolveHistory = function(){
    if (this.isSolved()){
      return solveHistory;
    } else {
      return "No solve history - Puzzle is not possible to solve.";
    }
  };
  
  this.getSolveHistoryString = function(){
    if (this.isSolved()){
      return getHistoryString.call(this, solveHistory);
    } else {
      return "No solve history - Puzzle is not possible to solve.";
    }
  };
  
  this.printSolveHistory = function(){
    if (this.isSolved()){
      printHistory(solveHistory);
    } else {
      println("No solve history - Puzzle is not possible to solve.");
    }
  };
  
  this.setRecordHistory = function(recHistory){
    recordHistory = recHistory;
  };
  
  this.setLogHistory = function(logHist){
    logHistory = logHist;
  };
  
  this.setPrintStyle = function(ps){
    printStyle = ps;
  };
  
  this.generatePuzzle = function(){
    return this.generatePuzzleSymmetry(qqwing.Symmetry.NONE);
  };
  
  this.generatePuzzleSymmetry = function(symmetry){
      if (symmetry == qqwing.Symmetry.RANDOM) symmetry = getRandomSymmetry.call(this);
  
      
      var recHistory = recordHistory;
      this.setRecordHistory(false);
      var lHistory = logHistory;
      this.setLogHistory(false);
  
      clearPuzzle.call(this);
  
      
      
      shuffleRandomArrays.call(this);
  
      
      
      
      
      this.solve();
  
      if (symmetry == qqwing.Symmetry.NONE){
        
        
        
        
        rollbackNonGuesses.call(this);
      }
  
      
      
      for (var i=0; i<qqwing.BOARD_SIZE; i++){
        puzzle[i] = solution[i];
      }
  
      
      
      shuffleRandomArrays.call(this);
  
      
      
      
      
      for (var i=0; i<qqwing.BOARD_SIZE; i++){
        
        var position = randomBoardArray[i];
        if (puzzle[position] > 0){
          var positionsym1 = -1;
          var positionsym2 = -1;
          var positionsym3 = -1;
          switch (symmetry){
            case qqwing.Symmetry.ROTATE90:
              positionsym2 = rowColumnToCell(qqwing.ROW_COL_SEC_SIZE-1-cellToColumn(position),cellToRow(position));
              positionsym3 = rowColumnToCell(cellToColumn(position),qqwing.ROW_COL_SEC_SIZE-1-cellToRow(position));
            case qqwing.Symmetry.ROTATE180:
              positionsym1 = rowColumnToCell(qqwing.ROW_COL_SEC_SIZE-1-cellToRow(position),qqwing.ROW_COL_SEC_SIZE-1-cellToColumn(position));
            break;
            case qqwing.Symmetry.MIRROR:
              positionsym1 = rowColumnToCell(cellToRow(position),qqwing.ROW_COL_SEC_SIZE-1-cellToColumn(position));
            break;
            case qqwing.Symmetry.FLIP:
              positionsym1 = rowColumnToCell(qqwing.ROW_COL_SEC_SIZE-1-cellToRow(position),cellToColumn(position));
            break;
          }
          
          
          var savedValue = puzzle[position];
          puzzle[position] = 0;
          var savedSym1 = 0;
          if (positionsym1 >= 0){
            savedSym1 = puzzle[positionsym1];
            puzzle[positionsym1] = 0;
          }
          var savedSym2 = 0;
          if (positionsym2 >= 0){
            savedSym2 = puzzle[positionsym2];
            puzzle[positionsym2] = 0;
          }
          var savedSym3 = 0;
          if (positionsym3 >= 0){
            savedSym3 = puzzle[positionsym3];
            puzzle[positionsym3] = 0;
          }
          reset.call(this);
          if (this.countSolutions(2, true) > 1){
            
            puzzle[position] = savedValue;
            if (positionsym1 >= 0 && savedSym1 != 0) puzzle[positionsym1] = savedSym1;
            if (positionsym2 >= 0 && savedSym2 != 0) puzzle[positionsym2] = savedSym2;
            if (positionsym3 >= 0 && savedSym3 != 0) puzzle[positionsym3] = savedSym3;
          }
        }
      }
  
      
      reset.call(this);
  
      
      this.setRecordHistory(recHistory);
      this.setLogHistory(lHistory);
  
      return true;
  };
  
  this.getGivenCount = function(){
    var count = 0;
    for (var i=0; i<qqwing.BOARD_SIZE; i++){
      if (puzzle[i] != 0) count++;
    }
    return count;
  };
  
  this.getSingleCount = function(){
    return getLogCount.call(this, solveInstructions, qqwing.LogType.SINGLE);
  }
  
  this.getHiddenSingleCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_SINGLE_ROW) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_SINGLE_COLUMN) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_SINGLE_SECTION)
    );
  };
  
  
  this.getNakedPairCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.NAKED_PAIR_ROW) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.NAKED_PAIR_COLUMN) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.NAKED_PAIR_SECTION)
    );
  };
  
  this.getHiddenPairCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_PAIR_ROW) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_PAIR_COLUMN) +
      getLogCount.call(this, solveInstructions, qqwing.LogType.HIDDEN_PAIR_SECTION)
    );
  };
  
  this.getBoxLineReductionCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.ROW_BOX)+
      getLogCount.call(this, solveInstructions, qqwing.LogType.COLUMN_BOX)
    );
  };
  
  
  this.getPointingPairTripleCount = function(){
    return (
      getLogCount.call(this, solveInstructions, qqwing.LogType.POINTING_PAIR_TRIPLE_ROW)+
      getLogCount.call(this, solveInstructions, qqwing.LogType.POINTING_PAIR_TRIPLE_COLUMN)
    );
  };
  
  this.getGuessCount = function(){
    return getLogCount.call(this, solveInstructions, qqwing.LogType.GUESS);
  };
  
  this.getBacktrackCount = function(){
    return getLogCount.call(this, solveHistory, qqwing.LogType.ROLLBACK);
  };
  
  this.getSolveInstructions = function(){
    if (this.isSolved()){
      return solveInstructions;
    } else {
      return "No solve instructions - Puzzle is not possible to solve.";
    }
  };
  
  this.getSolveInstructionsString = function(){
    if (this.isSolved()){
      return getHistoryString.call(this, solveInstructions);
    } else {
      return "No solve instructions - Puzzle is not possible to solve.";
    }
  };
  
  this.printSolveInstructions = function(){
    if (this.isSolved()){
      printHistory(solveInstructions);
    } else {
      println("No solve instructions - Puzzle is not possible to solve.");
    }
  };
  
  this.getDifficulty = function(){
    if (this.getGuessCount() > 0) return qqwing.Difficulty.EXPERT;
    if (this.getBoxLineReductionCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getPointingPairTripleCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getHiddenPairCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getNakedPairCount() > 0) return qqwing.Difficulty.INTERMEDIATE;
    if (this.getHiddenSingleCount() > 0) return qqwing.Difficulty.EASY;
    if (this.getSingleCount() > 0) return qqwing.Difficulty.SIMPLE;
    return qqwing.Difficulty.UNKNOWN;
  };
  
  this.getDifficultyAsString = function(){
    var difficulty = this.getDifficulty();
    switch (difficulty){
      case qqwing.Difficulty.EXPERT: return "Expert";
      case qqwing.Difficulty.INTERMEDIATE: return "Intermediate";
      case qqwing.Difficulty.EASY: return "Easy";
      case qqwing.Difficulty.SIMPLE: return "Simple";
      default: return "Unknown";
    }
  };
  };
  qqwing.PrintStyle = {
    ONE_LINE: 0,
    COMPACT: 1,
    READABLE: 2,
    CSV: 3
  };
  
  qqwing.Difficulty = {
    UNKNOWN: 0,
    SIMPLE: 1,
    EASY: 2,
    INTERMEDIATE: 3,
    EXPERT: 4
  };
  
  qqwing.Symmetry = {
    NONE: 0,
    ROTATE90: 1,
    ROTATE180: 2,
    MIRROR: 3,
    FLIP: 4,
    RANDOM: 5
  };
  
  qqwing.LogType = {
    GIVEN: 0,
    SINGLE: 1,
    HIDDEN_SINGLE_ROW: 2,
    HIDDEN_SINGLE_COLUMN: 3,
    HIDDEN_SINGLE_SECTION: 4,
    GUESS: 5,
    ROLLBACK: 6,
    NAKED_PAIR_ROW: 7,
    NAKED_PAIR_COLUMN: 8,
    NAKED_PAIR_SECTION: 9,
    POINTING_PAIR_TRIPLE_ROW: 10,
    POINTING_PAIR_TRIPLE_COLUMN: 11,
    ROW_BOX: 12,
    COLUMN_BOX: 13,
    HIDDEN_PAIR_ROW: 14,
    HIDDEN_PAIR_COLUMN: 15,
    HIDDEN_PAIR_SECTION: 16
  };
  
  qqwing.GRID_SIZE = 3;
  qqwing.ROW_COL_SEC_SIZE = qqwing.GRID_SIZE*qqwing.GRID_SIZE;
  qqwing.SEC_GROUP_SIZE = qqwing.ROW_COL_SEC_SIZE*qqwing.GRID_SIZE;
  qqwing.BOARD_SIZE = qqwing.ROW_COL_SEC_SIZE*qqwing.ROW_COL_SEC_SIZE;
  qqwing.POSSIBILITY_SIZE = qqwing.BOARD_SIZE*qqwing.ROW_COL_SEC_SIZE;
  function getMicroseconds(){
    return new Date().getTime() * 1000;
  }
  
  var workingButton = null;
  var puzzleStartTime;
  
  function generateNum(dat, num){
    if (!workingButton) return;
    if (num > 0){
      dat.qqwing.setRecordHistory(dat.printHistory || dat.printInstructions || dat.printStats || dat.difficulty!=qqwing.Difficulty.UNKNOWN);
      dat.qqwing.setPrintStyle(dat.printStyle);
      dat.qqwing.generatePuzzleSymmetry(dat.symmetry);
      if (dat.printSolution || dat.printHistory || dat.printStats || dat.printInstructions || dat.difficulty!=qqwing.Difficulty.UNKNOWN) dat.qqwing.solve();
      if (dat.difficulty==qqwing.Difficulty.UNKNOWN || dat.difficulty==dat.qqwing.getDifficulty()){
        dat.doneCount++;
        var output = dat.qqwing.getPuzzleString();
        if (dat.printSolution) output += dat.qqwing.getSolutionString();
        if (dat.printHistory) output += dat.qqwing.getSolveHistoryString();
        if (dat.printInstructions) output += dat.qqwing.getSolveInstructionsString();
        var puzzleDoneTime = getMicroseconds();
        if (dat.timer){
          var t = (puzzleDoneTime - puzzleStartTime)/1000.0;
          if (dat.printStyle == qqwing.PrintStyle.CSV){
            output += t+",";
          } else {
            output += "Time: "+t +" milliseconds\n";
          }
          puzzleStartTime = puzzleDoneTime;
        }
        if (dat.printStats) output += stats(dat);
        output += "\n";
        addOutput(output);
        num--;
      }
      setTimeout(function(){generateNum(dat,num)}, 0);
    } else {
      var applicationDoneTime = getMicroseconds();
      if (dat.timer){
        var t = (applicationDoneTime - dat.applicationStartTime)/1000000.0;
        addOutput(dat.doneCount+" puzzle"+((dat.doneCount==1)?"":"s")+" generated in "+t+" seconds.");
      }
      clearWorking('Generate');
    }
  }
  
  function clearWorking(s){
    setError('');
    if(workingButton && s) {
      workingButton.value=s;
      workingButton = null;
    }
    el('loader').classList.remove('active');
  }
  
  function el(elementid){
    return document.getElementById(elementid);
  }
  
  function startWork(button){
    el('output').innerHTML = "";
    if (button) {
      button.value = 'Stop';
      workingButton = button;
    }
    el('loader').classList.add('active');
  }
  
  function setError(s){
    if (s === '') {
      el('errorParent').classList.add('hidden');
    } else {
      el('error').innerHTML = s;
      el('errorParent').classList.remove('hidden');
    }
  }
  
  function addOutput(s){
    el('output').appendChild(document.createTextNode(s));
  }
  
  function getOptData(form){
    return {
      printSolution: form.printsolution && form.printsolution.checked,
      printPuzzle: form.printpuzzle && form.printpuzzle.checked,
      printHistory: form.printhistory.checked,
      printInstructions: form.printinstructions.checked,
      timer: form.timer.checked,
      countSolutions: form.countsolutions && form.countsolutions.checked,
      printStyle: parseInt(form.outputselect.value),
      printStats: form.printstats.checked,
      difficulty: form.difficultyselect?parseInt(form.difficultyselect.value):0,
      symmetry: form.symmetryselect?parseInt(form.symmetryselect.value):0,
      applicationStartTime: getMicroseconds(),
      qqwing: new qqwing(),
      doneCount: 0
    };
  }
  
  function csvHeader(dat, puzzle, solution){
    var h = "";
    if (puzzle) h += "Puzzle,";
    if (solution) h += "Solution,";
    if (dat.printHistory) h +="Solve History,";
    if (dat.printInstructions) h +="Solve Instructions,";
    if (dat.timer) h +="Time (milliseconds),";
    if (dat.printStats) h +="Givens,Singles,Hidden Singles,Naked Pairs,Hidden Pairs,Pointing Pairs/Triples,Box/Line Intersections,Guesses,Backtracks,Difficulty";
    h += "\n";
    return h;
  }
  
  function stats(dat){
    var s = "";
    var givenCount = dat.qqwing.getGivenCount();
    var singleCount = dat.qqwing.getSingleCount();
    var hiddenSingleCount = dat.qqwing.getHiddenSingleCount();
    var nakedPairCount = dat.qqwing.getNakedPairCount();
    var hiddenPairCount = dat.qqwing.getHiddenPairCount();
    var pointingPairTripleCount = dat.qqwing.getPointingPairTripleCount();
    var boxReductionCount = dat.qqwing.getBoxLineReductionCount();
    var guessCount = dat.qqwing.getGuessCount();
    var backtrackCount = dat.qqwing.getBacktrackCount();
    var difficultyString = dat.qqwing.getDifficultyAsString();
    if (dat.printStyle == qqwing.PrintStyle.CSV){
      s+=givenCount+"," +singleCount+","+hiddenSingleCount
          +","+nakedPairCount+","+hiddenPairCount
          +"," +pointingPairTripleCount +"," +boxReductionCount
          +","+guessCount+","+backtrackCount
          +","+difficultyString+",";
    } else {
      s+="Number of Givens: "+givenCount+"\n";
      s+="Number of Singles: "+singleCount+"\n";
      s+="Number of Hidden Singles: "+hiddenSingleCount +"\n";
      s+="Number of Naked Pairs: "+nakedPairCount +"\n";
      s+="Number of Hidden Pairs: "+hiddenPairCount +"\n";
      s+="Number of Pointing Pairs/Triples: "+pointingPairTripleCount +"\n";
      s+="Number of Box/Line Intersections: "+boxReductionCount +"\n";
      s+="Number of Guesses: "+guessCount +"\n";
      s+="Number of Backtracks: "+backtrackCount +"\n";
      s+="Difficulty: "+difficultyString+"\n";
    }
    return s;
  }
  
  function generate(form){
    clearWorking();
    if (workingButton){
      clearWorking('Generate');
    } else {
      startWork(form.generatebutton);
      var dat = getOptData(form);
      if (dat.printStyle == qqwing.PrintStyle.CSV) addOutput(csvHeader(dat, true, dat.printSolution));
      puzzleStartTime = getMicroseconds();
      generateNum(dat, form.generatenumber.value);
    }
  }
  
  function solve(form){
    clearWorking();
    if (workingButton){
      clearWorking('Solve');
    } else {
      var dat = getOptData(form);
      var puzzles = getPuzzles(form.tosolve.value);
      if (!puzzles.length) return setError("No puzzles were found. Puzzles must be 81 numbers with zeros or periods for the unknowns.<br>For example:<br><br><code><pre>.47..2....18.5.7.4..59...2...............9..2....713.9.72....3...1......5.38.....</pre></code>");
      startWork(form.solvebutton);
      if (dat.printStyle == qqwing.PrintStyle.CSV) addOutput(csvHeader(dat, dat.printPuzzle, true));
      solveNum(dat, puzzles);
    }
  }
  
  
  function solveNum(dat, puzzles){
    if (!workingButton) return;
    if (dat.doneCount<puzzles.length){
      puzzleStartTime = getMicroseconds();
      dat.qqwing.setRecordHistory(dat.printHistory || dat.printInstructions || dat.printStats || dat.difficulty!=qqwing.Difficulty.UNKNOWN);
      dat.qqwing.setPrintStyle(dat.printStyle);
      dat.qqwing.setPuzzle(puzzles[dat.doneCount]);
      dat.qqwing.solve();
      var output = "";
      if (dat.printPuzzle) output += dat.qqwing.getPuzzleString();
      if (!dat.qqwing.isSolved()){
        output += "Puzzle has no solution.";
        output += printStyle==qqwing.PrintStyle.CSV?",":"\n";
      } else {
        output += dat.qqwing.getSolutionString();
        if (dat.printHistory) output += dat.qqwing.getSolveHistoryString();
        if (dat.printInstructions) output += dat.qqwing.getSolveInstructionsString();
        if (dat.countSolutions){
          var solutions = dat.qqwing.countSolutions();
          if (dat.printStyle == qqwing.PrintStyle.CSV){
            output+= solutions+",";
          } else if (solutions == 1){
            output += "solution to the puzzle is unique.\n";
          } else {
            output += "There are "+solutions+" solutions to the puzzle.\n";
          }
        }
        var puzzleDoneTime = getMicroseconds();
        if (dat.timer){
          var t = (puzzleDoneTime - puzzleStartTime)/1000.0;
          if (dat.printStyle == qqwing.PrintStyle.CSV){
            output += t+",";
          } else {
            output += "Time: "+t +" milliseconds\n";
          }
        }
        if (dat.printStats) output += stats(dat);
        output += "\n";
      }
      addOutput(output);
      dat.doneCount++;
      setTimeout(function(){solveNum(dat,puzzles)}, 0);
    } else {
      var applicationDoneTime = getMicroseconds();
      if (dat.timer){
        var t = (applicationDoneTime - dat.applicationStartTime)/1000000.0;
        addOutput(dat.doneCount+" puzzle"+((dat.doneCount==1)?"":"s")+" in "+t+" seconds.");
      }
      clearWorking('Solve');
    }
  }
  
  function getPuzzles(s){
    var ps = [];
    var p = [];
    for (var i=0; i<s.length; i++){
      var c = s.charAt(i);
      if (c[0] >= '1' && c[0] <='9') p.push(c-'0');
      if (c[0] == '.' || c[0] == '0') p.push(0);
      if (p.length == qqwing.BOARD_SIZE){
        ps.push(p);
        p = [];
      }
    }
    return ps;
  
  }
  